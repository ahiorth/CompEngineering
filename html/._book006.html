<!--
File automatically generated using DocOnce (https://github.com/doconce/doconce/):
doconce format html book.do.txt CHAPTER=chapter BOOK=book APPENDIX=appendix --exercise_numbering=chapter --html_style=bootswatch_journal --html_code_style=inherit --html_output=book
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Modeling and Computational Engineering">
<meta name="keywords" content="types,basic types,lists,list comprehension,numerical error,Taylor polynomial,truncation error,Taylor polynomial, error term,Maclaurin series,forward difference,backward difference,central difference,central difference,roundoff erros,machine precision,IEEE 754-1985 standard,roundoff errors,continuity equation,finite volume,Gauss-Jordan elimination,pivoting,LU decomposition,Jacobi method,Gauss-Seidel method,linear regression,sparse matrix,Thomas algorithm,fixed-point iteration,rate of convergence,bisection method,rate of convergence,Newtons method,Newtons method, rate of convergence,secant method,secant method, rate of convergence,Newton Rapson method,gradient descent,midpoint method,trapezoidal method,numerical integrals, error,Richardson extrapolation,Romberg integration,Gaussian quadrature,Gaussian quadrature, error term,numerical integral, infinite,continuous stirred tank reactor (CSTR),Eulers method,Eulers method, error analysis,Eulers method, adaptive step size,Runge-Kutta,Runge-Kutta, adaptive step size,adaptive step size,stiff equations,implicit method,Monte Carlo integration,random number generators,Mersenne Twister,encryption,Monte Carlo Integration, error,binomial distribution,mean,variance,Monte Carlo integration, mean value,recursive functions,central limit theorem,birthday paradox">
<title>Modeling and Computational Engineering</title>
<!-- Bootstrap style: bootswatch_journal -->
<!-- doconce format html book.do.txt CHAPTER=chapter BOOK=book APPENDIX=appendix --exercise_numbering=chapter --html_style=bootswatch_journal --html_code_style=inherit --html_output=book -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:60px;      /* fixed header height for style bootswatch_journal */
  margin:-60px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              ('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Introduction to Python', 0, 'ch:pyt', 'ch:pyt'),
              ('Personal guidelines', 1, None, 'personal-guidelines'),
              ('Code editor', 2, None, 'code-editor'),
              ('Types in Python', 1, None, 'types-in-python'),
              ('Basic types', 2, None, 'basic-types'),
              ('Lists', 2, None, 'lists'),
              ('List arithmetic', 3, None, 'list-arithmetic'),
              ('List slicing', 3, None, 'list-slicing'),
              ('Numpy arrays', 2, None, 'numpy-arrays'),
              ('Array slicing', 3, None, 'array-slicing'),
              ('Dictionaries', 2, None, 'dictionaries'),
              ('Looping', 1, None, 'looping'),
              ('For-loops', 2, None, 'for-loops'),
              ('While-loops', 2, None, 'while-loops'),
              ('Functions in Python', 2, None, 'functions-in-python'),
              ('Defining a mathematical function',
               2,
               None,
               'defining-a-mathematical-function'),
              ('Scope of variables', 2, None, 'scope-of-variables'),
              ('Passing arrays and lists to functions',
               2,
               None,
               'passing-arrays-and-lists-to-functions'),
              ('Call by value or call by reference',
               2,
               None,
               'call-by-value-or-call-by-reference'),
              ('Floats and integers', 3, None, 'floats-and-integers'),
              ('Lists and arrays', 3, None, 'lists-and-arrays'),
              ('Mutable and immutable objects',
               2,
               None,
               'mutable-and-immutable-objects'),
              ('Introduction to Pandas', 0, 'ch:pan', 'ch:pan'),
              ('What is Pandas?', 1, None, 'what-is-pandas'),
              ('Creating a data frame', 1, None, 'creating-a-data-frame'),
              ('From an empty DataFrame', 2, None, 'from-an-empty-dataframe'),
              ('Create DataFrame from dictionary',
               2,
               None,
               'create-dataframe-from-dictionary'),
              ('From a file', 2, None, 'from-a-file'),
              ('Accessing data in  DataFrames',
               2,
               None,
               'accessing-data-in-dataframes'),
              ('Selecting columns', 3, None, 'selecting-columns'),
              ('Selecting rows', 3, None, 'selecting-rows'),
              ('Challenges when accessing columns or rows',
               3,
               None,
               'challenges-when-accessing-columns-or-rows'),
              ('Time columns not parsed properly',
               3,
               None,
               'time-columns-not-parsed-properly'),
              ('Filtering and visualizing data',
               2,
               None,
               'filtering-and-visualizing-data'),
              ('Boolean masking', 3, None, 'boolean-masking'),
              ('Plotting a DataFrame', 3, None, 'plotting-a-dataframe'),
              ('Performing mathematical operations on DataFrames',
               2,
               None,
               'performing-mathematical-operations-on-dataframes'),
              ('Example: mathematical operations on DataFrames',
               3,
               None,
               'example-mathematical-operations-on-dataframes'),
              ('Solution', 3, None, 'solution'),
              ('Grouping, filtering and aggregating data',
               2,
               None,
               'grouping-filtering-and-aggregating-data'),
              ('Simple statistics in Pandas',
               2,
               None,
               'simple-statistics-in-pandas'),
              ('Joining two DataFrames', 2, None, 'joining-two-dataframes'),
              ('Appending DataFrames', 3, None, 'appending-dataframes'),
              ('Merging DataFrames', 3, None, 'merging-dataframes'),
              ('Working with folders and files',
               2,
               None,
               'working-with-folders-and-files'),
              ('Basic use of Pathlib', 3, None, 'basic-use-of-pathlib'),
              ('Basic use of `os`', 3, None, 'basic-use-of-os'),
              ('Splitting data into different folders and files',
               3,
               None,
               'splitting-data-into-different-folders-and-files'),
              ('Writing more robust code', 2, None, 'writing-more-robust-code'),
              ('Finite differences', 0, 'ch:taylor', 'ch:taylor'),
              ('Why are gradients important?',
               1,
               None,
               'why-are-gradients-important'),
              ('Continuous functions and finite representation: numerical '
               'errors',
               1,
               None,
               'continuous-functions-and-finite-representation-numerical-errors'),
              ('Taylor polynomial approximation',
               1,
               None,
               'taylor-polynomial-approximation'),
              ('Calculating Numerical Derivatives of Functions',
               1,
               None,
               'calculating-numerical-derivatives-of-functions'),
              ('Higher order derivative',
               3,
               'sec:taylor:hhd',
               'sec:taylor:hhd'),
              ('Roundoff Errors', 2, None, 'roundoff-errors'),
              ('Binary numbers', 3, None, 'binary-numbers'),
              ('Floating point numbers and the IEEE 754-1985 standard',
               3,
               None,
               'floating-point-numbers-and-the-ieee-754-1985-standard'),
              ('Roundoff error and truncation error in numerical derivatives',
               3,
               None,
               'roundoff-error-and-truncation-error-in-numerical-derivatives'),
              ('Partial differential equations and linear systems',
               0,
               'ch:lin',
               'ch:lin'),
              ('The continuity equation', 1, None, 'the-continuity-equation'),
              ('Continuity equation as a linear problem',
               1,
               None,
               'continuity-equation-as-a-linear-problem'),
              ('Boundary conditions', 3, None, 'boundary-conditions'),
              ('Solving linear equations', 1, None, 'solving-linear-equations'),
              ('Gauss-Jordan elimination', 2, None, 'gauss-jordan-elimination'),
              ('Pivoting', 2, None, 'pivoting'),
              ('LU decomposition', 2, None, 'lu-decomposition'),
              ('Iterative methods', 1, None, 'iterative-methods'),
              ('Iterative improvement', 2, None, 'iterative-improvement'),
              ('The Jacobi method', 2, None, 'the-jacobi-method'),
              ('The Gauss-Seidel method', 2, None, 'the-gauss-seidel-method'),
              ('Example: Linear regression',
               1,
               None,
               'example-linear-regression'),
              ('Solving least square, using algebraic equations',
               2,
               None,
               'solving-least-square-using-algebraic-equations'),
              ('Least square as a linear algebra problem',
               2,
               None,
               'least-square-as-a-linear-algebra-problem'),
              ('Working with matrices on component form',
               2,
               None,
               'working-with-matrices-on-component-form'),
              ('Sparse matrices and Thomas algorithm',
               1,
               None,
               'sparse-matrices-and-thomas-algorithm'),
              ('Example: Solving the heat equation using linear algebra',
               1,
               None,
               'example-solving-the-heat-equation-using-linear-algebra'),
              ('Exercise 4.1: Conservation Equation or the Continuity Equation',
               2,
               None,
               'exercise-4-1-conservation-equation-or-the-continuity-equation'),
              ('Heat equation for solids', 3, None, 'heat-equation-for-solids'),
              ('Exercise 4.2: Curing of Concrete and Matrix Formulation',
               2,
               None,
               'exercise-4-2-curing-of-concrete-and-matrix-formulation'),
              ('Exercise 4.3: Solve the full heat equation',
               2,
               None,
               'exercise-4-3-solve-the-full-heat-equation'),
              ('Exercise 4.4: Using sparse matrices in python',
               2,
               None,
               'exercise-4-4-using-sparse-matrices-in-python'),
              ('CO$_2$ diffusion into aquifers',
               1,
               None,
               'co-2-diffusion-into-aquifers'),
              ('Optimization and nonlinear systems', 0, 'ch:nlin', 'ch:nlin'),
              ('Nonlinear equations', 1, None, 'nonlinear-equations'),
              ('Example: van der Waals equation of state',
               1,
               None,
               'example-van-der-waals-equation-of-state'),
              ('Exercise 5.1: van der Waal EOS and CO$_2$',
               2,
               None,
               'exercise-5-1-van-der-waal-eos-and-co-2'),
              ('Fixed-point iteration', 1, None, 'fixed-point-iteration'),
              ('Exercise 5.2: Implement the fixed point iteration',
               2,
               None,
               'exercise-5-2-implement-the-fixed-point-iteration'),
              ('Exercise 5.3: Finding the molar volume from the van der Waal '
               'EOS by fixed point iteration',
               2,
               None,
               'exercise-5-3-finding-the-molar-volume-from-the-van-der-waal-eos-by-fixed-point-iteration'),
              ('When does the fixed point method fail?',
               2,
               'sec:nlin:fp',
               'sec:nlin:fp'),
              ('What to do when the fixed point method fails',
               2,
               None,
               'what-to-do-when-the-fixed-point-method-fails'),
              ('Exercise 5.4: Solve $x=e^{1-x^2}$ using fixed point iteration',
               2,
               None,
               'exercise-5-4-solve-x-e-1-x-2-using-fixed-point-iteration'),
              ('Rate of convergence', 1, None, 'rate-of-convergence'),
              ('The bisection method', 1, None, 'the-bisection-method'),
              ('Rate of convergence', 2, None, 'rate-of-convergence'),
              ("Newton's method", 1, None, 'newton-s-method'),
              ('Rate of convergence', 2, None, 'rate-of-convergence'),
              ('Exercise 5.5: Compare Newtons, Bisection and the Fixed Point '
               'method',
               2,
               None,
               'exercise-5-5-compare-newtons-bisection-and-the-fixed-point-method'),
              ('Secant method', 1, None, 'secant-method'),
              ('Rate of convergence', 2, None, 'rate-of-convergence'),
              ('Newton Rapson method', 1, None, 'newton-rapson-method'),
              ('Gradient descent', 1, None, 'gradient-descent'),
              ('Exercise 5.6: Gradient descent solution of linear regression',
               2,
               None,
               'exercise-5-6-gradient-descent-solution-of-linear-regression'),
              ('Other useful methods', 1, None, 'other-useful-methods'),
              ('Numerical integration', 0, 'ch:numint', 'ch:numint'),
              ('Algorithmic thinking', 1, None, 'algorithmic-thinking'),
              ('The midpoint rule', 2, None, 'the-midpoint-rule'),
              ('The trapezoidal rule', 2, None, 'the-trapezoidal-rule'),
              ('Numerical errors on integrals',
               2,
               None,
               'numerical-errors-on-integrals'),
              ('Practical estimation of errors on integrals (Richardson '
               'extrapolation)',
               2,
               None,
               'practical-estimation-of-errors-on-integrals-richardson-extrapolation'),
              ('Romberg integration', 1, None, 'romberg-integration'),
              ('Alternative implementation of adaptive integration',
               2,
               None,
               'alternative-implementation-of-adaptive-integration'),
              ('Gaussian quadrature', 1, None, 'gaussian-quadrature'),
              ('The case N=3', 3, None, 'the-case-n-3'),
              ('Error term on Gaussian integration',
               2,
               None,
               'error-term-on-gaussian-integration'),
              ('Common weight functions for classical Gaussian quadratures',
               2,
               None,
               'common-weight-functions-for-classical-gaussian-quadratures'),
              ('Integrating functions over an infinite range',
               1,
               None,
               'integrating-functions-over-an-infinite-range'),
              ('Exercise 6.1: Numerical Integration',
               2,
               None,
               'exercise-6-1-numerical-integration'),
              ('Ordinary differential equations', 0, 'ch:ode', 'ch:ode'),
              ('0D models', 1, None, '0d-models'),
              ('Ordinary differential equations',
               1,
               None,
               'ordinary-differential-equations'),
              ('A simple model for fluid flow',
               1,
               None,
               'a-simple-model-for-fluid-flow'),
              ("Euler's method", 1, None, 'euler-s-method'),
              ("Error analysis - Euler's method",
               2,
               None,
               'error-analysis-euler-s-method'),
              ("Adaptive step size - Euler's method",
               2,
               None,
               'adaptive-step-size-euler-s-method'),
              ('Runge-Kutta methods', 1, None, 'runge-kutta-methods'),
              ('Adaptive step size - Runge-Kutta method',
               2,
               None,
               'adaptive-step-size-runge-kutta-method'),
              ('Conservation of mass', 2, None, 'conservation-of-mass'),
              ('Solving a set of ODE equations',
               1,
               None,
               'solving-a-set-of-ode-equations'),
              ('Stiff sets of ODE  and implicit methods',
               1,
               None,
               'stiff-sets-of-ode-and-implicit-methods'),
              ("Exercise 7.1: Truncation error in Euler's method",
               2,
               None,
               'exercise-7-1-truncation-error-in-euler-s-method'),
              ('Monte Carlo Methods', 0, 'ch:mc', 'ch:mc'),
              ('Monte Carlo methods', 1, None, 'monte-carlo-methods'),
              ("Monte Carlo integration  ''hit and miss''",
               1,
               None,
               'monte-carlo-integration-hit-and-miss'),
              ('Random number generators', 2, None, 'random-number-generators'),
              ('Encryption', 2, None, 'encryption'),
              ('Errors on Monte Carlo integration and the binomial '
               'distribution',
               2,
               None,
               'errors-on-monte-carlo-integration-and-the-binomial-distribution'),
              ('The mean value method', 2, None, 'the-mean-value-method'),
              ('Basic properties of probability distributions',
               2,
               None,
               'basic-properties-of-probability-distributions'),
              ('Example: Monte Carlo integration of a hyper sphere',
               2,
               None,
               'example-monte-carlo-integration-of-a-hyper-sphere'),
              ('Exercise 8.1: The central limit theorem',
               2,
               'ex:mc:norm',
               'ex:mc:norm'),
              ('Remarks', 3, None, 'remarks'),
              ('Exercise 8.2: Birthday Paradox', 2, 'ex:mc:BP', 'ex:mc:BP'),
              ('References', 1, None, 'references')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\no}{\nonumber}
\newcommand{\co}{CO$_2$}
$$



<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="book.html">Modeling and Computational Engineering</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._book001.html#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="._book001.html#ch:preface" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#ch:pyt" style="font-size: 80%;"><b>Introduction to Python</b></a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#personal-guidelines" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Personal guidelines</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#code-editor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code editor</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#types-in-python" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Types in Python</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#basic-types" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic types</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#lists" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lists</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#list-arithmetic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List arithmetic</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#list-slicing" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List slicing</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#numpy-arrays" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numpy arrays</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#array-slicing" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array slicing</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#dictionaries" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionaries</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#looping" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Looping</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#for-loops" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For-loops</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#while-loops" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While-loops</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#functions-in-python" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions in Python</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#defining-a-mathematical-function" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defining a mathematical function</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#scope-of-variables" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scope of variables</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#passing-arrays-and-lists-to-functions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Passing arrays and lists to functions</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#call-by-value-or-call-by-reference" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Call by value or call by reference</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#floats-and-integers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floats and integers</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#lists-and-arrays" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lists and arrays</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#mutable-and-immutable-objects" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mutable and immutable objects</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#ch:pan" style="font-size: 80%;"><b>Introduction to Pandas</b></a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#what-is-pandas" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What is Pandas?</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#creating-a-data-frame" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Creating a data frame</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#from-an-empty-dataframe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From an empty DataFrame</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#create-dataframe-from-dictionary" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create DataFrame from dictionary</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#from-a-file" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From a file</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#accessing-data-in-dataframes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessing data in  DataFrames</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#selecting-columns" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selecting columns</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#selecting-rows" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selecting rows</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#challenges-when-accessing-columns-or-rows" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Challenges when accessing columns or rows</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#time-columns-not-parsed-properly" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time columns not parsed properly</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#filtering-and-visualizing-data" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtering and visualizing data</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#boolean-masking" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean masking</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#plotting-a-dataframe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting a DataFrame</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#performing-mathematical-operations-on-dataframes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performing mathematical operations on DataFrames</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#example-mathematical-operations-on-dataframes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: mathematical operations on DataFrames</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#solution" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#grouping-filtering-and-aggregating-data" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Grouping, filtering and aggregating data</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#simple-statistics-in-pandas" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple statistics in Pandas</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#joining-two-dataframes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Joining two DataFrames</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#appending-dataframes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Appending DataFrames</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#merging-dataframes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merging DataFrames</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#working-with-folders-and-files" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with folders and files</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#basic-use-of-pathlib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic use of Pathlib</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#basic-use-of-os" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic use of <code>os</code></a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#splitting-data-into-different-folders-and-files" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splitting data into different folders and files</a></li>
     <!-- navigation toc: --> <li><a href="._book002.html#writing-more-robust-code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing more robust code</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#ch:taylor" style="font-size: 80%;"><b>Finite differences</b></a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#why-are-gradients-important" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Why are gradients important?</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#continuous-functions-and-finite-representation-numerical-errors" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Continuous functions and finite representation: numerical errors</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#taylor-polynomial-approximation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Taylor polynomial approximation</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#calculating-numerical-derivatives-of-functions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Calculating Numerical Derivatives of Functions</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#sec:taylor:hhd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Higher order derivative</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#roundoff-errors" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Roundoff Errors</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#binary-numbers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary numbers</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#floating-point-numbers-and-the-ieee-754-1985-standard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating point numbers and the IEEE 754-1985 standard</a></li>
     <!-- navigation toc: --> <li><a href="._book003.html#roundoff-error-and-truncation-error-in-numerical-derivatives" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Roundoff error and truncation error in numerical derivatives</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#ch:lin" style="font-size: 80%;"><b>Partial differential equations and linear systems</b></a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#the-continuity-equation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The continuity equation</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#continuity-equation-as-a-linear-problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Continuity equation as a linear problem</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#boundary-conditions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#solving-linear-equations" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving linear equations</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#gauss-jordan-elimination" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gauss-Jordan elimination</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#pivoting" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pivoting</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#lu-decomposition" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LU decomposition</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#iterative-methods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#iterative-improvement" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative improvement</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#the-jacobi-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Jacobi method</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#the-gauss-seidel-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Gauss-Seidel method</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#example-linear-regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: Linear regression</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#solving-least-square-using-algebraic-equations" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving least square, using algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#least-square-as-a-linear-algebra-problem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Least square as a linear algebra problem</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#working-with-matrices-on-component-form" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with matrices on component form</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#sparse-matrices-and-thomas-algorithm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Sparse matrices and Thomas algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#example-solving-the-heat-equation-using-linear-algebra" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: Solving the heat equation using linear algebra</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#exercise-4-1-conservation-equation-or-the-continuity-equation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4.1: Conservation Equation or the Continuity Equation</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#heat-equation-for-solids" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heat equation for solids</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#exercise-4-2-curing-of-concrete-and-matrix-formulation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4.2: Curing of Concrete and Matrix Formulation</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#exercise-4-3-solve-the-full-heat-equation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4.3: Solve the full heat equation</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#exercise-4-4-using-sparse-matrices-in-python" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4.4: Using sparse matrices in python</a></li>
     <!-- navigation toc: --> <li><a href="._book004.html#co-2-diffusion-into-aquifers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;CO$_2$ diffusion into aquifers</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#ch:nlin" style="font-size: 80%;"><b>Optimization and nonlinear systems</b></a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#nonlinear-equations" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Nonlinear equations</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#example-van-der-waals-equation-of-state" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: van der Waals equation of state</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#exercise-5-1-van-der-waal-eos-and-co-2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.1: van der Waal EOS and CO$_2$</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#fixed-point-iteration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Fixed-point iteration</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#exercise-5-2-implement-the-fixed-point-iteration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.2: Implement the fixed point iteration</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#exercise-5-3-finding-the-molar-volume-from-the-van-der-waal-eos-by-fixed-point-iteration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.3: Finding the molar volume from the van der Waal EOS by fixed point iteration</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#sec:nlin:fp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When does the fixed point method fail?</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#what-to-do-when-the-fixed-point-method-fails" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What to do when the fixed point method fails</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#exercise-5-4-solve-x-e-1-x-2-using-fixed-point-iteration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.4: Solve \( x=e^{1-x^2} \) using fixed point iteration</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#rate-of-convergence" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Rate of convergence</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#the-bisection-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The bisection method</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#rate-of-convergence" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rate of convergence</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#newton-s-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#rate-of-convergence" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rate of convergence</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#exercise-5-5-compare-newtons-bisection-and-the-fixed-point-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.5: Compare Newtons, Bisection and the Fixed Point method</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#secant-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Secant method</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#rate-of-convergence" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rate of convergence</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#newton-rapson-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton Rapson method</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#gradient-descent" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Gradient descent</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#exercise-5-6-gradient-descent-solution-of-linear-regression" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.6: Gradient descent solution of linear regression</a></li>
     <!-- navigation toc: --> <li><a href="._book005.html#other-useful-methods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Other useful methods</a></li>
     <!-- navigation toc: --> <li><a href="#ch:numint" style="font-size: 80%;"><b>Numerical integration</b></a></li>
     <!-- navigation toc: --> <li><a href="#algorithmic-thinking" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Algorithmic thinking</a></li>
     <!-- navigation toc: --> <li><a href="#the-midpoint-rule" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The midpoint rule</a></li>
     <!-- navigation toc: --> <li><a href="#the-trapezoidal-rule" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The trapezoidal rule</a></li>
     <!-- navigation toc: --> <li><a href="#numerical-errors-on-integrals" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical errors on integrals</a></li>
     <!-- navigation toc: --> <li><a href="#practical-estimation-of-errors-on-integrals-richardson-extrapolation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Practical estimation of errors on integrals (Richardson extrapolation)</a></li>
     <!-- navigation toc: --> <li><a href="#romberg-integration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Romberg integration</a></li>
     <!-- navigation toc: --> <li><a href="#alternative-implementation-of-adaptive-integration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative implementation of adaptive integration</a></li>
     <!-- navigation toc: --> <li><a href="#gaussian-quadrature" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Gaussian quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#the-case-n-3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The case N=3</a></li>
     <!-- navigation toc: --> <li><a href="#error-term-on-gaussian-integration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error term on Gaussian integration</a></li>
     <!-- navigation toc: --> <li><a href="#common-weight-functions-for-classical-gaussian-quadratures" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Common weight functions for classical Gaussian quadratures</a></li>
     <!-- navigation toc: --> <li><a href="#integrating-functions-over-an-infinite-range" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Integrating functions over an infinite range</a></li>
     <!-- navigation toc: --> <li><a href="#exercise-6-1-numerical-integration" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.1: Numerical Integration</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#ch:ode" style="font-size: 80%;"><b>Ordinary differential equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#0d-models" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;0D models</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#ordinary-differential-equations" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Ordinary differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#a-simple-model-for-fluid-flow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A simple model for fluid flow</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#euler-s-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Euler's method</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#error-analysis-euler-s-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error analysis - Euler's method</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#adaptive-step-size-euler-s-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adaptive step size - Euler's method</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#runge-kutta-methods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Runge-Kutta methods</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#adaptive-step-size-runge-kutta-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adaptive step size - Runge-Kutta method</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#conservation-of-mass" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conservation of mass</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#solving-a-set-of-ode-equations" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving a set of ODE equations</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#stiff-sets-of-ode-and-implicit-methods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Stiff sets of ODE  and implicit methods</a></li>
     <!-- navigation toc: --> <li><a href="._book007.html#exercise-7-1-truncation-error-in-euler-s-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 7.1: Truncation error in Euler's method</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#ch:mc" style="font-size: 80%;"><b>Monte Carlo Methods</b></a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#monte-carlo-methods" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Monte Carlo methods</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#monte-carlo-integration-hit-and-miss" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Monte Carlo integration  ''hit and miss''</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#random-number-generators" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random number generators</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#encryption" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encryption</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#errors-on-monte-carlo-integration-and-the-binomial-distribution" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Errors on Monte Carlo integration and the binomial distribution</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#the-mean-value-method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mean value method</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#basic-properties-of-probability-distributions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic properties of probability distributions</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#example-monte-carlo-integration-of-a-hyper-sphere" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: Monte Carlo integration of a hyper sphere</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#ex:mc:norm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 8.1: The central limit theorem</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#remarks" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._book008.html#ex:mc:BP" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 8.2: Birthday Paradox</a></li>
     <!-- navigation toc: --> <li><a href="._book009.html#references" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<a name="part0006"></a>
<!-- !split -->

<center>
<h1 id="ch:numint" class="anchor">Numerical integration</h1>
</center> <!-- chapter heading -->
<h1 id="algorithmic-thinking" class="anchor">Algorithmic thinking </h1>

<p>The only way to improve in coding and algorithmic thinking is practice. The concept of one dimensional numerical integration is easy to understand, i.e. to calculate the area under a curve. In this chapter we will implement several numerical methods, and it will serve as a very simple playground that illustrates the key aspects of numerical modeling</p>

<ol>
<li> We start with a mathematical model (in this case an integral)</li>
<li> The mathematical model is formulated in discrete form</li> 
<li> Then we design an algorithm to solve the model</li> 
<li> The numerical solution for a test case is compared with the true solution (could be an analytical solution or data)</li>
<li> Error analysis: we investigate the accuracy of the algorithm by changing the number of iterations and/or make changes to the implementation or algorithm</li>
</ol>
<p>The main point of this chapter is not to develop your own integration methods, the built in methods in Scipy will work in most cases. However, the way to break down the main task of calculating an integral into smaller tasks that is understandable by a computer, may work as a template for many different problems you would typically solve using a computer. A second motivation is that by analyzing the origin of numerical errors gives ideas for improving the algorithm, which is transferable to other problems.      </p>
<h2 id="the-midpoint-rule" class="anchor">The midpoint rule </h2>
<p>Numerical integration is encountered in numerous applications in physics and engineering sciences. 
Let us first consider the most simple case, a function \( f(x) \), which is a function of one variable, \( x \). The most straight forward way of calculating the area \( \int_a^bf(x)dx \) is 
simply to divide the area under the function into \( N \) equal rectangular slices with size \( h=(b-a)/N \), as illustrated in figure <a href="#fig:numint:mid">32</a>. The area of one box is:
</p>
$$
\begin{equation}
M(x_k,x_k+h)=f(x_k+\frac{h}{2}) h,\tag{7.1}
\end{equation}
$$

<p>and the area of all the boxes is:</p>
$$
\begin{align}
I(a,b)&=\int_a^bf(x)dx\simeq\sum_{k=0}^{N-1}M(x_k,x_k+h)\nonumber\\ 
&=h\sum_{k=0}^{N-1}f(x_k+\frac{h}{2})=h\sum_{k=0}^{N-1}f(a+(k+\frac{1}{2})h).
\tag{7.2}
\end{align}
$$

<p>Note that the sum goes from \( k=0,1,\ldots,N-1 \), a total of \( N \) elements. We could have chosen to let the sum go from \( k=1,2,\ldots,N \). 
In Python, C, C++ and many other programming languages the arrays start by indexing the elements from \( 0,1,\ldots \) to \( N-1 \), 
therefore we choose the convention of having the first element to start at \( k=0 \).
</p>

<center> <!-- figure label: --> <div id="fig:numint:mid"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 32: Integrating a function with the midpoint rule.  <!-- caption label: fig:numint:mid --></p>
</center>
<p><img src="fig-numint/func_sq.png" width="800" align="bottom"></p>
</center>

<p>Below is a Python code, where this algorithm is implemented for \( \int_0^\pi\sin (x)dx \)</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #3D7B7B; font-style: italic"># Function to be integrated</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>sin(x)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint</span>(f,a,b,N):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    f : function to be integrated on the domain [a,b]</span>
<span style="color: #BA2121; font-style: italic">    N : number of integration points</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    h<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>N
    x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>arange(a<span style="color: #666666">+0.5*</span>h,b,h)
    <span style="color: #008000; font-weight: bold">return</span> h<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(f(x))
N<span style="color: #666666">=10</span>
a<span style="color: #666666">=0</span>
b<span style="color: #666666">=</span>np<span style="color: #666666">.</span>pi
Area <span style="color: #666666">=</span> midpoint(f,a,b,N)
<span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;Numerical value= &#39;</span>, Area)
<span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;Error= &#39;</span>, (<span style="color: #666666">2-</span>Area)) <span style="color: #3D7B7B; font-style: italic"># Analytical result is 2</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<div class="alert alert-block alert-success alert-text-normal"><b>Notice</b>
<p>In the implementation above, we have taken advantage of Numpys ability to pass a vector to a function. This greatly enhances the speed and makes clean, readable code. If you were coding in a lower level programming language like Fortran, C or C++, you would probably implement the loop like (in Python syntax):</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #ffffff">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,N): <span style="color: #3D7B7B; font-style: italic"># loop over k=0,1,..,N-1</span>
    val <span style="color: #666666">=</span> lower_limit<span style="color: #666666">+</span>(k<span style="color: #666666">+0.5</span>)<span style="color: #666666">*</span>h <span style="color: #3D7B7B; font-style: italic"># midpoint value</span>
    area <span style="color: #666666">+=</span> func(val)
<span style="color: #008000; font-weight: bold">return</span> area<span style="color: #666666">*</span>h
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</div>

<h2 id="the-trapezoidal-rule" class="anchor">The trapezoidal rule </h2>
<p>The numerical error in the above example is quite low, only about 2$\%$ for \( N=5 \). 
However, by just looking at the graph above it seems likely that we can develop a better algorithm by using trapezoids instead of rectangles, 
see figure <a href="#fig:numint:trap">33</a>.
</p>

<center> <!-- figure label: --> <div id="fig:numint:trap"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 33: Integrating a function with the trapezoidal rule.  <!-- caption label: fig:numint:trap --></p>
</center>
<p><img src="fig-numint/func_tr.png" width="800" align="bottom"></p>
</center>

<p>Earlier we approximated the area using the midpoint value: \( f(x_k+h/2)\cdot h \). Now we use \( A=A_1+A_2 \), where \( A_1=f(x_k)\cdot h \) 
and \( A_2=(f(x_k+h)-f(x_k))\cdot h/2 \), hence the area of one trapezoid is:
</p>
$$
\begin{equation}
A\equiv T(x_k,x_k+h)=(f(x_k+h)+f(x_k))h/2.
\tag{7.3}
\end{equation}
$$

<p>This is the trapezoidal rule, and for the whole interval we get:</p>
$$
\begin{align}
I(a,b)&=\int_a^bf(x)dx\simeq\frac{1}{2}h\sum_{k=0}^{N-1}\left[f(x_k+h)+f(x_k)\right] \nonumber \\ 
&=h\left[\frac{1}{2}f(a)+f(a+h) + f(a+2h) +\nonumber\right. \\ 
&\left.\qquad\cdots + f(a+(N-2)h)+\frac{1}{2}f(b)\right]\nonumber \\ 
&=h\left[\frac{1}{2}f(a)+\frac{1}{2}f(b)+\sum_{k=1}^{N-2}f(a+k h)\right].
\tag{7.4}
\end{align}
$$

<p>Note that this formula was bit more involved to derive, but it requires only one more function evaluations compared to the midpoint rule. 
Below is a python implementation:
</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">trapezoidal</span>(f,a,b,N):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    f : function to be integrated on the domain [a,b]</span>
<span style="color: #BA2121; font-style: italic">    N : number of integration points</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    h<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>N
    x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>arange(a<span style="color: #666666">+</span>h,b,h)
    <span style="color: #008000; font-weight: bold">return</span> h<span style="color: #666666">*</span>(<span style="color: #666666">0.5*</span>f(a)<span style="color: #666666">+0.5*</span>f(b)<span style="color: #666666">+</span>np<span style="color: #666666">.</span>sum(f(x)))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>In the table below, we have calculated the numerical error for various values of \( N \).</p>

<div class="row">
  <div class="col-xs-5">
    <table class="dotable table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( N \)</td> <td align="center">\( h \)</td> <td align="center"><b>Error Midpoint</b></td> <td align="center"><b>Error Trapezoidal</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   1          </td> <td align="center">   3.14       </td> <td align="center">   -57\%             </td> <td align="center">   100\%                </td> </tr>
<tr><td align="center">   5          </td> <td align="center">   0.628      </td> <td align="center">   -1.66\%           </td> <td align="center">   3.31\%               </td> </tr>
<tr><td align="center">   10         </td> <td align="center">   0.314      </td> <td align="center">   -0.412\%          </td> <td align="center">   0.824\%              </td> </tr>
<tr><td align="center">   100        </td> <td align="center">   0.031      </td> <td align="center">   -4.11E-3\%        </td> <td align="center">   8.22E-3\%            </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-5 -->
</div> <!-- cell row -->

<p>Note that we get the surprising result that this algorithm performs poorer, a factor of 2 than the midpoint rule.
How can this be explained? By just looking at figure <a href="#fig:numint:mid">32</a>, we see that the midpoint rule actually over predicts the area from \( [x_k,x_k+h/2] \) 
 and under predicts in the interval \( [x_k+h/2,x_{k+1}] \) or vice versa. The net effect is that for many cases the midpoint rule give a slightly better 
 performance than the trapezoidal rule. In the next section we will investigate this more formally.
</p>
<h2 id="numerical-errors-on-integrals" class="anchor">Numerical errors on integrals </h2>
<p>It is important to know the accuracy of the methods we are using, otherwise we do not know if the
computer produce correct results. In the previous examples we were able to estimate the error because we knew the analytical result. However, if we know the 
analytical result there is no reason to use the computer to calculate the result(!). Thus, we need a general method to estimate the error, and let the computer 
run until a desired accuracy is reached. 
</p>

<p>In order to analyze the midpoint rule in more detail we approximate the function by a Taylor 
series at the midpoint between \( x_k \) and \( x_k+h \): 
</p>
$$
\begin{align}
f(x)&=f(x_k+h/2)+f^\prime(x_k+h/2)(x-(x_k+h/2))\nonumber\\ 
&+\frac{1}{2!}f^{\prime\prime}(x_k+h/2)(x-(x_k+h/2))^2+\mathcal{O}(h^3)
\tag{7.5}
\end{align}
$$

<p>Since \( f(x_k+h/2) \) and its derivatives are constants it is straight forward to integrate \( f(x) \):</p>
$$
\begin{align}
I(x_k,x_k+h)&=\int_{x_k}^{x_k+h}\left[f(x_k+h/2)+f^\prime(x_k+h/2)(x-(x_k+h/2))\right.\nonumber\\ 
&\left.+\frac{1}{2!}f^{\prime\prime}(x_k+h/2)(x-(x_k+h/2))^2+\mathcal{O}(h^3)\right]dx
\tag{7.6}
\end{align}
$$

<p>The first term is simply the midpoint rule, to evaluate the two other terms we make the substitution: \( u=x-x_k \):</p>
$$
\begin{align}
I(x_k,x_k+h)&=f(x_k+h/2)\cdot h+f^\prime(x_k+h/2)\int_0^h(u-h/2)du\nonumber\\ 
&+\frac{1}{2}f^{\prime\prime}(x_k+h/2)\int_0^h(u-h/2)^2du+\mathcal{O}(h^4)\nonumber\\ 
&=f(x_k+h/2)\cdot h-\frac{h^3}{24}f^{\prime\prime}(x_k+h/2)+\mathcal{O}(h^4).
\tag{7.7}
\end{align}
$$

<p>Note that all the odd terms cancels out, i.e \( \int_0^h(u-h/2)^m=0 \) for \( m=1,3,5\ldots \). Thus the error for the midpoint rule, \( E_{M,k} \), on this particular interval is:</p>
$$
\begin{equation}
E_{M,k}=I(x_k,x_k+h)-f(x_k+h/2)\cdot h=-\frac{h^3}{24}f^{\prime\prime}(x_k+h/2),
\tag{7.8}
\end{equation}
$$

<p>where we have ignored higher order terms. We can easily sum up the error on all the intervals, but clearly \( f^{\prime\prime}(x_k+h/2) \) will 
not, in general, have the same value on all intervals. However, an upper bound for the error can be found by replacing \( f^{\prime\prime}(x_k+h/2) \) 
with the maximal value on the interval \( [a,b] \), \( f^{\prime\prime}(\eta) \):
</p>
$$
\begin{align}
E_{M}&=\sum_{k=0}^{N-1}E_{M,k}=-\frac{h^3}{24}\sum_{k=0}^{N-1}f^{\prime\prime}(x_k+h/2)\leq-\frac{Nh^3}{24}f^{\prime\prime}(\eta),\tag{7.9}\\ 
E_{M}&\leq-\frac{(b-a)^3}{24N^2}f^{\prime\prime}(\eta),
\tag{7.10}
\end{align}
$$

<p>where we have used \( h=(b-a)/N \). We can do the exact same analysis for the trapezoidal rule, but then we expand the function around \( x_k-h \) instead of the midpoint. 
The error term is then:
</p>
$$
\begin{equation}
E_T=\frac{(b-a)^3}{12N^2}f^{\prime\prime}(\overline{\eta}).
\tag{7.11}
\end{equation}
$$

<p>At the first glance it might look like the midpoint rule always is better than the trapezoidal rule, but note that the second derivative is 
evaluated in different points (\( \eta \) and \( \overline{\eta} \)). Thus it is possible to construct examples where the midpoint rule performs poorer 
than the trapezoidal rule.
</p>

<p>Before we end this section we will rewrite the error terms in a more useful form as it is not so easy to evaluate 
\( f^{\prime\prime}(\eta) \) (since we do not know which value of \( \eta \) to use). By taking a closer look at equation <a href="#mjx-eqn-7.9">(7.9)</a>, 
we see that it is closely related to the midpoint rule for \( \int_a^bf^{\prime\prime}(x)dx \), hence:
</p>
$$
\begin{align}
E_{M}&=-\frac{h^2}{24}h
\sum_{k=0}^{N-1}f^{\prime\prime}(x_k+h/2)\simeq-\frac{h^2}{24}\int_a^b
f^{\prime\prime}(x)dx
\tag{7.12}\\ 
E_M&\simeq\frac{h^2}{24}\left[f^\prime(b)-f^\prime(a)\right]=-\frac{(b-a)^2}{24N^2}\left[f^\prime(b)-f^\prime(a)\right]
\tag{7.13}
\end{align}
$$

<p>The corresponding formula for the trapezoid formula is:</p>
$$
\begin{equation}
E_T\simeq \frac{h^2}{12}\left[f^\prime(b)-f^\prime(a)\right]=\frac{(b-a)^2}{12N^2}\left[f^\prime(b)-f^\prime(a)\right]
\tag{7.14}
\end{equation}
$$
<h2 id="practical-estimation-of-errors-on-integrals-richardson-extrapolation" class="anchor">Practical estimation of errors on integrals (Richardson extrapolation) </h2>
<div id="sec:numint:parct"></div>
<p>From the example above we were able to estimate the number of steps needed to reach (at least) a certain precision. 
In many practical cases we do not deal with functions, but with data and it can be difficult to evaluate the derivative. 
We also saw from the example above that the algorithm gives a higher precision than what we asked for. 
How can we avoid doing too many iterations? A very simple solution to this question is to double the number of intervals until 
a desired accuracy is reached. The following analysis holds for both the trapezoid and midpoint method, because in both cases 
the (global) error scale as \( h^2 \) <button type="button" class="btn btn-primary btn-xs" rel="tooltip" data-placement="top" title="You can do the following analysis by assuming that the local error is \( h^3 \), but then you need to take into account that you need to take twice as many steps, which will give the same result."><a href="#def_footnote_1" id="link_footnote_1" style="color: white">1</a></button>.
</p>

<p id="def_footnote_1"><a href="#link_footnote_1"><b>1:</b></a> You can do the following analysis by assuming that the local error is \( h^3 \), but then you need to take into account that you need to take twice as many steps, which will give the same result.</p>

<p>Assume that we have evaluated the integral with a step size \( h_1 \), and the computed result is \( I_1 \). 
Then we know that the true integral is \( I=I_1+c h_1^2 \), where \( c \) is a constant that is unknown. If we now half the step size: \( h_2=h_1/2 \), 
then we get a new (better) estimate of the integral, \( I_2 \), which is related to the true integral \( I \) as: \( I=I_2+c h_2^2 \). 
Taking the difference between \( I_2 \) and \( I_1 \) give us an estimation of the error:
</p>
$$
\begin{equation}
I_2-I_1=I-c h_2^2-(I-ch_1^2)=3c h_2^2,
\tag{7.15}
\end{equation}
$$

<p>where we have used the fact that \( h_1=2h_2 \), Thus the error term is:</p>
$$
\begin{equation}
E(a,b)=c h_2^2=\frac{1}{3}(I_2-I_1).
\tag{7.16}
\end{equation}
$$

<p>This might seem like we need to evaluate the integral twice as many times as needed. This is not the case, by choosing to exactly 
half the spacing we only need to evaluate for the values that lies halfway between the original points. We will demonstrate how 
to do this by using the trapezoidal rule, because it operates directly on the \( x_k \) values and not the midpoint values. 
The trapezoidal rule can now be written as:
</p>
$$
\begin{align}
I_2(a,b)&=h_2\left[\frac{1}{2}f(a)+\frac{1}{2}f(b)+\sum_{k=1}^{N_2-1}f(a+k h_2)\right],
\tag{7.17}\\ 
&=h_2\left[\frac{1}{2}f(a)+\frac{1}{2}f(b)+\sum_{k=\text{even values}}^{N_2-1}f(a+k h_2)\right.\nonumber\\ 
&\left.\qquad+\sum_{k=\text{odd values}}^{N_2-1}f(a+k h_2)\right],
\tag{7.18}
\end{align}
$$

<p>in the last equation we have split the sum into odd an even values. The sum over the even values can be rewritten:</p>
$$
\begin{equation}
\sum_{k=\text{even values}}^{N_2-1}f(a+k h_2)=\sum_{k=0}^{N_1-1}f(a+2k h_2)=\sum_{k=0}^{N_1-1}f(a+k h_1),
\tag{7.19}
\end{equation}
$$

<p>note that \( N_2 \) is replaced with \( N_1=N_2/2 \), we can now rewrite \( I_2 \) as:</p>
$$
\begin{align}
I_2(a,b)&=h_2\left[\frac{1}{2}f(a)+\frac{1}{2}f(b)+\sum_{k=0}^{N_1-1}f(a+k h_1)\right.\nonumber\\ 
&\left.+\sum_{k=\text{odd values}}^{N_2-1}f(a+k h_2)\right]
\tag{7.20}
\end{align}
$$

<p>Note that the first terms are actually the trapezoidal rule for \( I_1 \), hence:</p>
$$
\begin{equation}
I_2(a,b)=\frac{1}{2}I_1(a,b)+h_2\sum_{k=\text{odd values}}^{N_2-1}f(a+k h_2).
\tag{7.21}
\end{equation}
$$

<p>The factor \( 1/2 \) in front of \( I_1(a,b) \), appears because \( h_2=h_1/2 \). 
A possible algorithm is then:
</p>
<ol>
<li> Choose a low number of steps to evaluate the integral, \( I_0 \), the first time, e.g. \( N_0=1 \)</li>
<li> Double the number of steps, \( N_1=2N_0 \)</li> 
<li> Calculate the missing values by summing over the odd number of steps \( \sum_{k=\text{odd values}}^{N_1-1}f(a+k h_1) \)</li>
<li> Check if \( E_1(a,b)=\frac{1}{3}(I_1-I_0) \) is lower than a specific tolerance</li>
<li> If yes quit, if not, return to 2, and continue until \( E_i(a,b)=\frac{1}{3}(I_{i+1}-I_{i}) \) is lower than the tolerance</li>  
</ol>
<p>Below is a Python implementation:</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">int_adaptive_trapez2</span>(lower_limit, upper_limit,func,tol):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    adaptive quadrature, integrate a function from lower_limit</span>
<span style="color: #BA2121; font-style: italic">    to upper_limit within tol*(upper_limit-lower_limit)</span>

<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    S<span style="color: #666666">=</span>[]
    S<span style="color: #666666">.</span>append([lower_limit,upper_limit])
    I<span style="color: #666666">=0</span>
    iterations<span style="color: #666666">=0</span>
    <span style="color: #008000; font-weight: bold">while</span> S:
        iterations <span style="color: #666666">+=1</span>
        a,b<span style="color: #666666">=</span>S<span style="color: #666666">.</span>pop(<span style="color: #666666">-1</span>) <span style="color: #3D7B7B; font-style: italic"># last element</span>
        m<span style="color: #666666">=</span>(b<span style="color: #666666">+</span>a)<span style="color: #666666">*0.5</span>   <span style="color: #3D7B7B; font-style: italic"># midpoint</span>
        I1<span style="color: #666666">=0.5*</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">*</span>(func(a)<span style="color: #666666">+</span>func(b)) <span style="color: #3D7B7B; font-style: italic">#trapezoidal for 1 interval </span>
        I2<span style="color: #666666">=0.25*</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">*</span>(func(a)<span style="color: #666666">+</span>func(b)<span style="color: #666666">+2*</span>func(m)) <span style="color: #3D7B7B; font-style: italic">#trapezoidal for 2 intervals</span>
        <span style="color: #008000; font-weight: bold">if</span>(np<span style="color: #666666">.</span>abs(I1<span style="color: #666666">-</span>I2)<span style="color: #666666">&lt;3*</span>np<span style="color: #666666">.</span>abs((b<span style="color: #666666">-</span>a)<span style="color: #666666">*</span>tol)):
            I<span style="color: #666666">+=</span>I2     <span style="color: #3D7B7B; font-style: italic"># accuarcy met</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            S<span style="color: #666666">.</span>append([a,m]) <span style="color: #3D7B7B; font-style: italic"># half the interval </span>
            S<span style="color: #666666">.</span>append([m,b])
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Number of iterations: &quot;</span>, iterations)
    <span style="color: #008000; font-weight: bold">return</span> I
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>If you compare the number of terms used in the adaptive trapezoidal rule, which was developed by halving the step size, and the adaptive midpoint rule that was derived on the basis of the theoretical error term, you will find the adaptive midpoint rule is more efficient. So why go through all this trouble? In the next section we will see that the development we did for the adaptive trapezoidal rule is closely related to Romberg integration, which is <em>much</em> more effective.</p>
<h1 id="romberg-integration" class="anchor">Romberg integration </h1>
<p>The adaptive algorithm for the trapezoidal rule in the previous section can be easily improved by remembering 
that the true integral was given by <button type="button" class="btn btn-primary btn-xs" rel="tooltip" data-placement="top" title="Note that all odd powers of \( h \) is equal to zero, thus the corrections are always in even powers."><a href="#def_footnote_2" id="link_footnote_2" style="color: white">2</a></button> : \( I=I_i+ch_i^2+\mathcal{O}(h^4) \). The error term was in the previous example only used to 
check if the desired tolerance was achieved, but we could also have added it to our estimate of the integral to reach an accuracy to fourth order:
</p>

<p id="def_footnote_2"><a href="#link_footnote_2"><b>2:</b></a> Note that all odd powers of \( h \) is equal to zero, thus the corrections are always in even powers.</p>

$$
\begin{equation}
I=I_{i+1}+ch^2+\mathcal{O}(h^4)=I_{i+1}+\frac{1}{3}\left[I_{i+1}-I_{i}\right]+\mathcal{O}(h^4).
\tag{7.22}
\end{equation}
$$

<p>As before the error term \( \mathcal{O}(h^4) \), can be written as: \( ch^4 \). Now we can proceed as in the previous section: First we estimate the 
integral by one step size \( I_i=I+ch_i^4 \), next we half the step size \( I_{i+1}=I+ch_{i+1}^4 \) and use these two estimates to calculate the error term:
</p>
$$
\begin{align}
I_{i+1}-I_{i}&=I-c h_{i+1}^4-(I-ch_i^4)=-c h_{i+1}^4+c(2h_{i+1})^4=15c h_{i+1}^4,\nonumber\\ 
ch_{i+1}^4&=\frac{1}{15}\left[I_{i+1}-I_{i}\right]+\mathcal{O}(h^6).
\tag{7.23}
\end{align}
$$

<p>but now we are in the exact situation as before, we have not only the error term but the correction up to order \( h^4 \) for this integral:</p>
$$
\begin{equation}
I=I_{i+1}+\frac{1}{15}\left[I_{i+1}-I_{i}\right]+\mathcal{O}(h^6).\tag{7.24}
\end{equation}
$$

<p>Each time we half the step size we also gain a higher order accuracy in our numerical algorithm. Thus, there are two iterations going on at the same time; 
one is the iteration that half the step size (\( i \)), and the other one is the increasing number of higher order terms added (which we will denote \( m \)). 
We need to improve our notation, and replace the approximation of the integral (\( I_i \)) with \( R_{i,m} \). Equation <a href="#mjx-eqn-7.24">(7.24)</a>, can now 
be written:
</p>
$$
\begin{equation}
I=R_{i+1,2}+\frac{1}{15}\left[R_{i+1,2}-R_{i,2}\right]+\mathcal{O}(h^6).
\tag{7.25}
\end{equation}
$$

<p>A general formula valid for any \( m \) can be found by realizing:</p>
$$
\begin{align}
I&=R_{i+1,m+1}+c_mh_i^{2m+2}+\mathcal{O}(h_i^{2m+4})\tag{7.26}\\ 
I&=R_{i,m+1}+c_mh_{i-1}^{2m+2}+\mathcal{O}(h_{i-1}^{2m+4})\nonumber\\ 
&=R_{i,m+1}+2^{2m+2}c_mh_{i}^{2m+2}+\mathcal{O}(h_{i-1}^{2m+4}),\tag{7.27}
\end{align}
$$

<p>where, as before \( h_{i-1}=2h_i \). Subtracting equation <a href="#mjx-eqn-7.26">(7.26)</a> and <a href="#mjx-eqn-7.27">(7.27)</a>, we find an expression for the error term:</p>
$$
\begin{align}
c_mh_{i}^{2m+2}&=\frac{1}{4^{m+1}-1}(R_{i,m}-R_{i-1,m})\tag{7.28}
\end{align}
$$

<p>Then the estimate for the integral in equation <a href="#mjx-eqn-7.27">(7.27)</a> is:</p>
$$
\begin{align}
I&=R_{i,m+1}+\mathcal{O}(h_i^{2m+2})
\tag{7.29}\\ 
R_{i,m+1}&=R_{i,m}+\frac{1}{4^{m+1}-1}(R_{i+1,m}-R_{i,m}).
\tag{7.30}
\end{align}
$$

<p>A possible algorithm is then:</p>

<ol>
<li> Evaluate \( R_{0,0}=\frac{1}{2}\left[f(a)+f(b)\right](b-a) \) as the first estimate</li>
<li> Double the number of steps, \( N_{i+1}=2N_i \) or half the step size \( h_{i+1}=h_i/2 \)</li> 
<li> Calculate the missing values by summing over the odd number of steps \( \sum_{k=\text{odd values}}^{N_1-1}f(a+k h_{i+1}) \)</li>
<li> Correct the estimate by adding <em>all</em> the higher order error term \( R_{i,m+1}=R_{i,m}+\frac{1}{4^m-1}(R_{i+1,m+1}-R_{i,m+1}) \)</li>
<li> Check if the error term is lower than a specific tolerance \( E_{i,m}(a,b)=\frac{1}{4^{m+1}-1}(R_{i,m}-R_{i-1,m}) \), if yes quit, if no goto 2, increase \( i \) and \( m \) by one</li>
</ol>
<p>The algorithm is illustrated in figure <a href="#fig:numint:romberg">34</a>.</p>

<center> <!-- figure label: --> <div id="fig:numint:romberg"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 34: Illustration of the Romberg algorithm. Note that for each new evaluation of the integral \( R_{i,0} \), all the correction terms \( R_{i,m} \) (for \( m>0 \)) must be evaluated again.  <!-- caption label: fig:numint:romberg --></p>
</center>
<p><img src="fig-numint/romberg.png" width="400" align="bottom"></p>
</center>

<p>Note that the tolerance term is not the correct one as it uses the error estimate for the current step, 
which we also use correct the integral in the current step to reach a higher accuracy. 
Thus the error on the integral will always be lower than the user specified tolerance.
Below is a Python implementation:
</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">int_romberg</span>(func,a, b,tol,show<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">False</span>):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; calculates the area of func on the domain [a,b]</span>
<span style="color: #BA2121; font-style: italic">        for the given tol, if show=True the triangular</span>
<span style="color: #BA2121; font-style: italic">        array of intermediate results are printed &quot;&quot;&quot;</span>
    Nmax <span style="color: #666666">=</span> <span style="color: #666666">100</span>
    R <span style="color: #666666">=</span> np<span style="color: #666666">.</span>empty([Nmax,Nmax]) <span style="color: #3D7B7B; font-style: italic"># storage buffer</span>
    h <span style="color: #666666">=</span> (b<span style="color: #666666">-</span>a) <span style="color: #3D7B7B; font-style: italic"># step size</span>
    R[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]    <span style="color: #666666">=.5*</span>(func(a)<span style="color: #666666">+</span>func(b))<span style="color: #666666">*</span>h
    N <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,Nmax):
        h <span style="color: #666666">/=</span> <span style="color: #666666">2</span>
        N <span style="color: #666666">*=</span> <span style="color: #666666">2</span>
        odd_terms<span style="color: #666666">=0</span>
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span> (<span style="color: #666666">1</span>,N,<span style="color: #666666">2</span>): <span style="color: #3D7B7B; font-style: italic"># 1, 3, 5, ... , N-1</span>
            val        <span style="color: #666666">=</span> a <span style="color: #666666">+</span> k<span style="color: #666666">*</span>h
            odd_terms <span style="color: #666666">+=</span> func(val)
		<span style="color: #3D7B7B; font-style: italic"># add the odd terms to the previous estimate	</span>
        R[i,<span style="color: #666666">0</span>]   <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>R[i<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">+</span> h<span style="color: #666666">*</span>odd_terms 
        <span style="color: #008000; font-weight: bold">for</span> m <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i): 
			<span style="color: #3D7B7B; font-style: italic"># add all higher order terms in h</span>
            R[i,m<span style="color: #666666">+1</span>]   <span style="color: #666666">=</span> R[i,m] <span style="color: #666666">+</span> (R[i,m]<span style="color: #666666">-</span>R[i<span style="color: #666666">-1</span>,m])<span style="color: #666666">/</span>(<span style="color: #666666">4**</span>(m<span style="color: #666666">+1</span>)<span style="color: #666666">-1</span>)                  
		<span style="color: #3D7B7B; font-style: italic"># check tolerance, best guess			</span>
        calc_tol <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(R[i,i]<span style="color: #666666">-</span>R[i<span style="color: #666666">-1</span>,i<span style="color: #666666">-1</span>])       
        <span style="color: #008000; font-weight: bold">if</span>(calc_tol<span style="color: #666666">&lt;</span>tol):
            <span style="color: #008000; font-weight: bold">break</span>  <span style="color: #3D7B7B; font-style: italic"># estimated precision reached </span>
    <span style="color: #008000; font-weight: bold">if</span>(i <span style="color: #666666">==</span> Nmax<span style="color: #666666">-1</span>):
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;Romberg routine did not converge after &#39;</span>,
              Nmax, <span style="color: #BA2121">&#39;iterations!&#39;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:      
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;Number of intervals = &#39;</span>, N)

    <span style="color: #008000; font-weight: bold">if</span>(show<span style="color: #666666">==</span><span style="color: #008000; font-weight: bold">True</span>):
        elem <span style="color: #666666">=</span> [<span style="color: #666666">2**</span>idx <span style="color: #008000; font-weight: bold">for</span> idx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i<span style="color: #666666">+1</span>)]
        <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Steps StepSize Results&quot;</span>)
        <span style="color: #008000; font-weight: bold">for</span> idx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i<span style="color: #666666">+1</span>):
            <span style="color: #008000">print</span>(elem[idx],<span style="color: #BA2121">&#39; &#39;</span>,
                  <span style="color: #BA2121">&quot;</span><span style="color: #A45A77; font-weight: bold">{:.6f}</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>format((b<span style="color: #666666">-</span>a)<span style="color: #666666">/2**</span>idx),end <span style="color: #666666">=</span> <span style="color: #BA2121">&#39; &#39;</span>)
            <span style="color: #008000; font-weight: bold">for</span> l <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(idx<span style="color: #666666">+1</span>):
                <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;</span><span style="color: #A45A77; font-weight: bold">{:.6f}</span><span style="color: #BA2121">&quot;</span><span style="color: #666666">.</span>format(R[idx,l]),end <span style="color: #666666">=</span> <span style="color: #BA2121">&#39; &#39;</span>)
            <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;&#39;</span>)  
    <span style="color: #008000; font-weight: bold">return</span> R[i,i] <span style="color: #3D7B7B; font-style: italic">#return the best estimate</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that the Romberg integration only uses 32 function evaluations to reach a precision of \( 10^{-8} \), whereas the adaptive midpoint and trapezoidal rule in the previous
section uses 20480 and 9069 function evaluations, respectively. 
</p>
<h2 id="alternative-implementation-of-adaptive-integration" class="anchor">Alternative implementation of adaptive integration </h2>
<p>Before we proceed, we will consider an alternative implementation of the adaptive method presented in the previous sections, with the following modification</p>
<ol>
<li> We will use Simpsons rule (see the exercise at the end), which takes the following form \( \int_a^bf(x)dx\simeq\frac{h}{6}\left[f(a)+4f(a+\frac{h}{2})+2f(a+h)+ 4f(a+3\frac{h}{2})+2f(a+2h)+\cdots+f(b)\right] \)</li>
<li> We only divide the intervals needed to reach the desired accuracy.</li>
</ol>
<p>Simpsons rule is accurate up to \( \mathcal{O}(h^4) \), and by following the same arguments as above we can estimate the error as \( E_i(a,b)=\frac{1}{15}(I_{i+1}-I_{i}) \). The factor 1/15 (as opposed to 1/3) originates from the higher order accuracy. The integration proceeds as follows</p>
<ul>
<li> <code>S</code> is an empty list</li>
<li> <code>S.append([a,b])</code></li>
<li> \( I=0 \)</li>
<li> <code>while S not empty do:</code></li>
<ul>
  <li> <code>[a,b]=S.pop(-1)</code></li>
  <li> \( m=(b+a)/2 \)</li>
  <li> \( I_1= \) <code>simpson_step(a,b)</code></li>
  <li> \( I_2= \) <code>simpson_step(a,m)+simpson_step(m,b)</code></li>
  <li> if \( |I_1-I_2| < 15|b-a|\cdot tol \)</li>
<ul>
    <li> \( I+=I_2 \)</li>
</ul>
  <li> else:</li>
<ul>
    <li> <code>S.append([a,m])</code></li>
    <li> <code>S.append([m,b])</code></li>
</ul>
  <li> return \( I \)</li>
</ul>
</ul>
<p>Note the use of the list <code>S</code>, we remove the interval \( [a,b] \) from the list and calculates the integral. If the integral is not accurate enough we add to new intervals to the list, and continue until we reach the desired accuracy, then we proceed with the next interval. Since we remove (<code>pop</code>) the element from the list, we know that we will finish the evaluation once the list is empty. This algorithm allows for different sub interval to have different degrees of subdivisions, contrary to Rombergs algorithm. The full python implementation is shown below</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">simpson_step</span>(a, b,func):
    m<span style="color: #666666">=0.5*</span>(a<span style="color: #666666">+</span>b)
    <span style="color: #008000; font-weight: bold">return</span> (b<span style="color: #666666">-</span>a)<span style="color: #666666">/6*</span>(func(a)<span style="color: #666666">+</span>func(b)<span style="color: #666666">+4*</span>func(m))

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">int_adaptive_simpson</span>(func,a, b,tol):
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    adaptive quadrature, integrate a function from a</span>
<span style="color: #BA2121; font-style: italic">    to b within tol*(b-a) uses simpsons rule</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    S<span style="color: #666666">=</span>[]
    S<span style="color: #666666">.</span>append([a,b])
    I<span style="color: #666666">=0</span>
    iterations<span style="color: #666666">=0</span>
    <span style="color: #008000; font-weight: bold">while</span> S:
        iterations <span style="color: #666666">+=1</span>
        a,b<span style="color: #666666">=</span>S<span style="color: #666666">.</span>pop(<span style="color: #666666">-1</span>) <span style="color: #3D7B7B; font-style: italic"># last element</span>
        m<span style="color: #666666">=</span>(b<span style="color: #666666">+</span>a)<span style="color: #666666">*0.5</span>   <span style="color: #3D7B7B; font-style: italic"># midpoint</span>
        I1<span style="color: #666666">=</span>simpson_step(a,b,func) <span style="color: #3D7B7B; font-style: italic">#simpsons for 1 interval </span>
        I2<span style="color: #666666">=</span>simpson_step(a,m,func)<span style="color: #666666">+</span>simpson_step(m,b,func) <span style="color: #3D7B7B; font-style: italic"># ...2 intervals</span>
        <span style="color: #008000; font-weight: bold">if</span>(np<span style="color: #666666">.</span>abs(I1<span style="color: #666666">-</span>I2)<span style="color: #666666">&lt;15*</span>np<span style="color: #666666">.</span>abs((b<span style="color: #666666">-</span>a)<span style="color: #666666">*</span>tol)):
            I<span style="color: #666666">+=</span>I2     <span style="color: #3D7B7B; font-style: italic"># accuarcy met</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            S<span style="color: #666666">.</span>append([a,m]) <span style="color: #3D7B7B; font-style: italic"># half the interval </span>
            S<span style="color: #666666">.</span>append([m,b])
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&quot;Number of iterations: &quot;</span>, iterations)
    <span style="color: #008000; font-weight: bold">return</span> I
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h1 id="gaussian-quadrature" class="anchor">Gaussian quadrature </h1>
<p>Many of the methods we have looked into are of the type:</p>
$$
\begin{align}
	\int_a^b f(x) dx = \sum_{k=0}^{N-1} \omega_k f(x_k),\tag{7.31}
\end{align}
$$

<p>where the function is evaluated at fixed interval. For the midpoint rule \( \omega_k=h \) for all values of \( k \), for the trapezoid rule 
\( \omega_k=h/2 \) for the endpoints and \( h \) for all the interior points. 
For the Simpsons rule (see exercise) \( \omega_k=h/3, 4h/3,2h/3,4h/3,\ldots,4h/3,h/3 \). 
Note that all the methods we have looked at so far samples the function in equal spaced points, \( f(a+k h) \), 
for \( k=0, 1, 2\ldots, N-1 \). If we now allow for the function to be evaluated at unevenly spaced points, we can do a lot better. 
This realization is the basis for Gaussian Quadrature. We will explore this in the following, 
but to make the development easier and less cumbersome, we transform the integral from the domain \( [a,b] \) to \( [-1,1] \):
</p>
$$
\begin{align}
\int_a^bf(t)dt&=\frac{b-a}{2}\int_{-1}^{1}f(x)dx\text{ , where:}
\tag{7.32}\\ 
x&=\frac{2}{b-a}t-\frac{b+a}{b-a}.
\tag{7.33}
\end{align}
$$

<p>The factor in front comes from the fact that \( dt=(b-a)dx/2 \), thus we can develop our algorithms on the domain \( [-1,1] \), 
and then do the transformation back using: \( t=(b-a)x/2+(b+a)/2 \).
</p>

<div class="alert alert-block alert-success alert-text-normal"><b>Notice</b>
<p>The idea we will explore is as follows:
If we can approximate the function to be integrated on the domain \( [-1,1] \) (or on \( [a,b] \)) as a 
polynomial of as <em>large a degree as possible</em>, then the numerical integral of this polynomial will be very close to the integral of the 
function we are seeking.
</p>
</div>

<p>This idea is best understood by a couple of examples. Assume that we want to use \( N=1 \) in equation <a href="#mjx-eqn-7.31">(7.31)</a>:</p>
$$
\begin{equation}
\int_{-1}^{1}f(x)\,dx\simeq\omega_0f(x_0).
\tag{7.34}
\end{equation}
$$

<p>We now choose \( f(x) \) to be a polynomial of as large a degree as possible, but with the requirement that the integral is exact. If \( f(x)=1 \), we get:</p>
$$
\begin{equation}
\int_{-1}^{1}f(x)\,dx=\int_{-1}^{1}1\,dx=2=\omega_0,
\tag{7.35}
\end{equation}
$$

<p>hence \( \omega_0=2 \). If we choose \( f(x)=x \), we get:</p>
$$
\begin{equation}
\int_{-1}^{1}f(x)\,dx=\int_{-1}^{1}x\,dx=0=\omega_0f(x_0)=2x_0,
\tag{7.36}
\end{equation}
$$

<p>hence \( x_0=0 \). </p>
<div class="alert alert-block alert-success alert-text-normal"><b>The Gaussian integration rule for \( N=1 \) is:</b>

$$
\begin{align}
&\int_{-1}^{1}f(x)\,dx\simeq 2f(0)\text{, or: }\nonumber\\ 
&\int_{a}^{b}f(t)\,dt\simeq\frac{b-a}{2}\,2f(\frac{b+a}{2})=(b-a)f(\frac{b+a}{2}).
\tag{7.37}
\end{align}
$$
</div>


<p>This equation is equal to the midpoint rule, by choosing \( b=a+h \) we reproduce equation <a href="#mjx-eqn-7.1">(7.1)</a>. If we choose \( N=2 \):</p>
$$
\begin{equation}
\int_{-1}^{1}f(x)\,dx\simeq\omega_0f(x_0)+\omega_1f(x_1),
\tag{7.38}
\end{equation}
$$

<p>we can show that now $ f(x)=1,\,x,\,x^2\,x^3$ can be integrated exact:</p>
$$
\begin{align}
\int_{-1}^{1}1\,dx&=2=\omega_0f(x_0)+\omega_1f(x_1)=\omega_0+\omega_1\,,
\tag{7.39}\\ 
\int_{-1}^{1}x\,dx&=0=\omega_0f(x_0)+\omega_1f(x_1)=\omega_0x_0+\omega_1x_1\,,
\tag{7.40}\\ 
\int_{-1}^{1}x^2\,dx&=\frac{2}{3}=\omega_0f(x_0)+\omega_1f(x_1)=\omega_0x_0^2+\omega_1x_1^2\,,
\tag{7.41}\\ 
\int_{-1}^{1}x^3\,dx&=0=\omega_0f(x_0)+\omega_1f(x_1)=\omega_0x_0^3+\omega_1x_1^3\,,
\tag{7.42}
\end{align}
$$

<p>hence there are four unknowns and four equations. The solution is: \( \omega_0=\omega_1=1 \) and \( x_0=-x_1=1/\sqrt{3} \).</p>

<div class="alert alert-block alert-success alert-text-normal"><b>The Gaussian integration rule for \( N=2 \) is:</b>
$$
\begin{align}
\int_{-1}^{1}f(x)\,dx&\simeq f(-\frac{1}{\sqrt{3}})+f(\frac{1}{\sqrt{3}})\, \text{, or:}
\tag{7.43}\\ 
\int_{a}^{b}f(x)\,dx&\simeq \frac{b-a}{2}\left[f(-\frac{b-a}{2}\frac{1}{\sqrt{3}}+\frac{b+a}{2})
+f(\frac{b-a}{2}\frac{1}{\sqrt{3}}+\frac{b+a}{2})\right].
\tag{7.44}
\end{align}
$$
</div>



<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">int_gaussquad2</span>(func, lower_limit, upper_limit):
    x   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">-1/</span>np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3.</span>),<span style="color: #666666">1/</span>np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3</span>)])
    w   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>, <span style="color: #666666">1</span>])
    xp  <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(upper_limit<span style="color: #666666">-</span>lower_limit)<span style="color: #666666">*</span>x
    xp <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(upper_limit<span style="color: #666666">+</span>lower_limit)
    area <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(w<span style="color: #666666">*</span>func(xp))
    <span style="color: #008000; font-weight: bold">return</span> area<span style="color: #666666">*0.5*</span>(upper_limit<span style="color: #666666">-</span>lower_limit)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h3 id="the-case-n-3" class="anchor">The case N=3 </h3>
<p>For the case \( N=3 \), we find that \( f(x)=1,x,x^2,x^3,x^4,x^5 \) can be integrated exactly:</p>
$$
\begin{align}
\int_{-1}^{1}1\,dx&=2=\omega_0+\omega_1+\omega_2\,,
\tag{7.45}\\ 
\int_{-1}^{1}x\,dx&=0=\omega_0x_0+\omega_1x_1+\omega_2x_2\,,
\tag{7.46}\\ 
\int_{-1}^{1}x^2\,dx&=\frac{2}{3}=\omega_0x_0^2+\omega_1x_1^2+\omega_2x_2^2\,,
\tag{7.47}\\ 
\int_{-1}^{1}x^3\,dx&=0=\omega_0x_0^3+\omega_1x_1^3+\omega_2x_2^3\,,
\tag{7.48}\\ 
\int_{-1}^{1}x^4\,dx&=\frac{2}{5}=\omega_0x_0^4+\omega_1x_1^4+\omega_2x_2^4\,,
\tag{7.49}\\ 
\int_{-1}^{1}x^5\,dx&=0=\omega_0x_0^5+\omega_1x_1^5+\omega_2x_2^5\,,
\tag{7.50}
\end{align}
$$

<p>the solution to these equations are \( \omega_{0,1,2}=5/9, 8/9, 5/9 \) and \( x_{1,2,3}=-\sqrt{3/5},0,\sqrt{3/5} \). Below is a Python implementation:</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">int_gaussquad3</span>(lower_limit, upper_limit,func):
    x  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">-</span>np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3./5.</span>),<span style="color: #666666">0.</span>,np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3./5.</span>)])
    w  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">5./9.</span>, <span style="color: #666666">8./9.</span>, <span style="color: #666666">5./9.</span>])
    xp <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(upper_limit<span style="color: #666666">-</span>lower_limit)<span style="color: #666666">*</span>x
    xp <span style="color: #666666">+=</span> <span style="color: #666666">0.5*</span>(upper_limit<span style="color: #666666">+</span>lower_limit)
    area <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(w<span style="color: #666666">*</span>func(xp))
    <span style="color: #008000; font-weight: bold">return</span> area<span style="color: #666666">*0.5*</span>(upper_limit<span style="color: #666666">-</span>lower_limit)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note that the Gaussian quadrature converges very fast. From \( N=2 \) to \( N=3 \) function evaluation we reduce the error (in this specific case) 
from 6.5% to 0.1%. Our standard trapezoidal formula needs more than 20 function evaluations to achieve this, the Romberg method uses 4-5 function
evaluations. How can this be? If we use the standard Taylor formula for the function to be integrated, we know that for \( N=2 \) the Taylor 
formula must be integrated up to \( x^3 \), so the error term is proportional to \( h^4f^{(4)}(\xi) \) (where \( \xi \) is some x-value in \( [a,b] \)). 
\( h \) is the step size, and we can replace it with \( h\sim (b-a)/N \), thus the error scale as \( c_N/N^4 \) (where \( c_N \) is a constant). 
Following the same argument, we find for \( N=3 \) that the error term is \( h^6f^{(6)}(\xi) \) or that the error term scale as \( c_N/N^6 \). 
Each time we increase \( N \) by a factor of one, the error term reduces by \( N^2 \). Thus if we evaluate the integral for \( N=10 \), 
increasing to \( N=11 \) will reduce the error by a factor of \( 11^2=121 \).
</p>
<h2 id="error-term-on-gaussian-integration" class="anchor">Error term on Gaussian integration </h2>
<p>The Gaussian integration rule of order \( N \) integrates exactly a polynomial of order \( 2N-1 \). 
From Taylors error formula, see equation <a href="._book003.html#mjx-eqn-4.4">(4.4)</a> in the chapter <a href="._book003.html#ch:taylor">Finite differences</a>,
we can easily see that the error term must be of order \( 2N \), and be proportional to \( f^{(2N)}(\eta) \), see <a href="._book009.html#stoer2013">[7]</a> for more details on the derivation of error terms. The drawback with an analytical error term derived from series expansion is that it involves the derivative of the function. As we have already explained, this is very unpractical and it is much more practical to use the methods described in the section <a href="#sec:numint:parct">sec:numint:parct</a>. Let us consider this in more detail, assume that we evaluate the integral using first a Gaussian integration rule with \( N \) points, and then \( N+1 \) points. Our estimates of the "exact" integral, \( I \),  would then be:
</p>
$$
\begin{align}
 I&=I_N+ch_{N}^{2N},label{eq:numint:gerr1}\\ 
 I&=I_{N+1}+ch_{N+1}^{2N+1}.
\tag{7.51}
\end{align}
$$

<p>In principle \( h_{N+1}\neq h_{N} \), but in the following we will assume that \( h_N\simeq h_{N+1} \), and \( h\ll 1 \). Subtracting equation \eqref{eq:numint:gerr1} and <a href="#mjx-eqn-7.51">(7.51)</a> we can show that a reasonable estimate for the error term \( ch^{2N} \) would be:</p>
$$
\begin{equation}
ch^N= I_{N+1}-I_N.
\tag{7.52}
\end{equation}
$$

<p>If this estimate is lower than a given tolerance we can be quite confident that the higher order estimate \( I_{N+1} \) approximate the true integral within our error estimate. This is the method implemented in SciPy, <a href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.quadrature.html" target="_self"><tt>integrate.quadrature</tt></a></p>
<h2 id="common-weight-functions-for-classical-gaussian-quadratures" class="anchor">Common weight functions for classical Gaussian quadratures </h2>
<h1 id="integrating-functions-over-an-infinite-range" class="anchor">Integrating functions over an infinite range  </h1>
<p>Integrating a function over an infinite range can be done by the following trick. Assume that we would like to evaluate</p>
$$
\begin{equation}
\int_a^\infty f(x) dx.
\tag{7.53}
\end{equation}
$$

<p>If we introduce the following substitution</p>
$$
\begin{equation}
z=\frac{x-a}{1+x-a},
\tag{7.54}
\end{equation}
or equivalently
\begin{equation}
x=a+\frac{z}{1-z},
\tag{7.55}
\end{equation}
$$

<p>then if \( x=a \), \( z=0 \), and if \( x\to\infty \) then \( z\to1 \), hence:</p>
$$
\begin{equation}
\int_a^\infty f(x) dx = \int_0^1 f(a+\frac{z}{1-z}) \frac{dz}{(1-z)^2}.
\tag{7.56}
\end{equation}
$$


<!-- --- begin exercise --- -->
<h2 id="exercise-6-1-numerical-integration" class="anchor">Exercise 6.1: Numerical Integration </h2>

<!-- --- begin subexercise --- -->

<p>
<b>a)</b>
Show that for a linear function, \( y=a\cdot x+b \) both the trapezoidal rule and the rectangular rule are exact
</p>

<!-- --- end subexercise --- -->

<!-- --- begin subexercise --- -->

<p>
<b>b)</b>
Consider \( I(a,b)=\int_a^bf(x)dx \) for \( f(x)=x^2 \). The analytical result is \( I(a,b)=\frac{b^3-a^3}{3} \). Use the Trapezoidal and 
  Midpoint rule to evaluate these integrals and show that the error for the Trapezoidal rule is exactly twice as big as the Midpoint rule.
</p>

<!-- --- end subexercise --- -->

<!-- --- begin subexercise --- -->

<p>
<b>c)</b>
Use the fact that the error term on the trapezoidal rule is twice as big as the midpoint rule to derive Simpsons formula: \( I(a,b)=\sum_{k=0}^{N-1}I(x_k,x_k+h)=\frac{h}{6}\left[f(a)+ 4f(a+\frac{h}{2})+2f(a+h)+4f(a+3\frac{h}{2})+2f(a+2h)+\cdots+f(b)\right] \) Hint: \( I(x_k,x_k+h)=M(x_k,x_k+h)+E_M \) (midpoint rule) and \( I(x_k,x_k+h)=T(x_k,x_k+h)+E_T=T(x_k,x_k+h)-2E_M \) (trapezoidal rule).
</p>

<!-- --- begin solution of exercise --- -->

<p>
<p><a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_1" style="font-size: 80%;"></a>
</p>
<a href="#exer_11_1" data-toggle="collapse">
<p>
<b>Solution.</b>
</p>
</a>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_1">

<p>Simpsons rule is an improvement over the midpoint and trapezoidal rule. It can be derived in different ways, we will make use of 
the results in the previous section. If we assume that the second derivative is reasonably well behaved on the interval \( x_k \) 
and \( x_k+h \) and fairly constant we can assume that \( f^{\prime\prime}(\eta)\simeq f^{\prime\prime}(\overline{\eta}) \), hence \( E_T=-2E_M \).
</p>
$$
\begin{align}
I(x_k,x_k+h)&=M(x_k,x_k+h)+E_M\text{ (midpoint rule)}
\tag{7.57}\\ 
I(x_k,x_k+h)&=T(x_k,x_k+h)+E_T\nonumber\\ 
&=T(x_k,x_k+h)-2E_M\text{ (trapezoidal rule)},
\tag{7.58}
\end{align}
$$

<p>we can now cancel out the error term by multiplying the first equation with 2 and adding the equations:</p>
$$
\begin{align}
3I(x_k,x_k+h)&=2M(x_k,x_k+h)+T(x_k,x_k+h)
\tag{7.59}\\ 
&=2f(x_k+\frac{h}{2}) h+\left[f(x_k+h)+f(x_k)\right] \frac{h}{2}
\tag{7.60}\\ 
I(x_k,x_k+h)&=\frac{h}{6}\left[f(x_k)+4f(x_k+\frac{h}{2})+f(x_k+h)\right].
\tag{7.61}
\end{align}
$$

<p>Now we can do as we did in the case of the trapezoidal rule, sum over all the elements:</p>
$$
\begin{align}
I(a,b)&=\sum_{k=0}^{N-1}I(x_k,x_k+h)\nonumber\\ 
&=\frac{h}{6}\left[f(a)+ 4f(a+\frac{h}{2})+2f(a+h)+4f(a+3\frac{h}{2})\right.\nonumber\\ 
&\left.\qquad+2f(a+2h)+\cdots+f(b)\right]
\tag{7.62}\\ 
&=\frac{h^\prime}{3}\left[f(a)+ f(b) + 4\sum_{k= \text{odd}}^{N-2}f(a+k h^\prime)+2\sum_{k= \text{even}}^{N-2}f(a+k h^\prime)\right],
\tag{7.63}
\end{align}
$$

<p>note that in the last equation we have changed the step size \( h=2h^\prime \).</p>
</div></p>
</div>
</p>

<!-- --- end solution of exercise --- -->

<!-- --- end subexercise --- -->

<!-- --- begin subexercise --- -->

<p>
<b>d)</b>
Show that for \( N=2 \) (\( f(x)=1,x,x^3 \)), the points and Gaussian quadrature rule for \( \int_{0}^{1}x^{1/2}f(x)\,dx \)
is \( \omega_{0,1}=-\sqrt{70}{150} + 1/3, \sqrt{70}{150} + 1/3 \)
and \( x_{0,1}=-2\sqrt{70}{63} + 5/9, 2\sqrt{70}{63} + 5/9 \)
</p>
<ol>
<li> Integrate \( \int_0^1x^{1/2}\cos x\,dx \) using the rule derived in the exercise above and compare with the standard Gaussian quadrature rule for (\( N=2 \), and \( N=3 \)).</li>
</ol>
<!-- --- end subexercise --- -->

<!-- --- begin subexercise --- -->

<p>
<b>e)</b>
Make a Python program that uses the Midpoint rule to integrate experimental data that are unevenly spaced and given in the form of two arrays.
</p>

<!-- --- end subexercise --- -->

<!-- --- end exercise --- -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._book005.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._book007.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
</body>
</html>

