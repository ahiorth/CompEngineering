<!--
File automatically generated using DocOnce (https://github.com/doconce/doconce/):
doconce format html project4.do.txt LANG=C.UTF-8 --html_style=bootswatch_readable --html_output=project4-readable --html_code_style=inherit
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Random walking dead">
<title>Random walking dead</title>
<!-- Bootstrap style: bootswatch_readable -->
<!-- doconce format html project4.do.txt LANG=C.UTF-8 --html_style=bootswatch_readable --html_output=project4-readable --html_code_style=inherit -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:64px;      /* fixed header height for style bootswatch_readable */
  margin:-64px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Introduction', 1, 'sec:introduction', 'sec:introduction'),
              ('Exercise 1: Random walk $SZ$-model',
               1,
               None,
               'exercise-1-random-walk-sz-model'),
              ('Exercise 2: Compare random walk and ODE-based models',
               1,
               None,
               'exercise-2-compare-random-walk-and-ode-based-models'),
              ('Exercise 3: Scenario what happens in Sokndal and Dirdal?',
               1,
               None,
               'exercise-3-scenario-what-happens-in-sokndal-and-dirdal'),
              ('Exercise 4: Compare your results with SZR model',
               1,
               None,
               'exercise-4-compare-your-results-with-szr-model'),
              ('Exercise 5: Implement your own scenario',
               1,
               None,
               'exercise-5-implement-your-own-scenario'),
              ('Appendix A: How to implement the random walk?',
               1,
               'appendix:random_walk_suggestions',
               'appendix:random_walk_suggestions'),
              ('Position of Walkers', 3, None, 'position-of-walkers'),
              ('Move walkers', 3, None, 'move-walkers'),
              ('Revert illegal moves (Bounce-back condition)',
               3,
               None,
               'revert-illegal-moves-bounce-back-condition'),
              ('State of Walkers', 3, None, 'state-of-walkers'),
              ('Checking for new infections',
               3,
               None,
               'checking-for-new-infections'),
              ('Appendix B: Speeding up the code',
               1,
               None,
               'appendix-b-speeding-up-the-code'),
              ('Appendix C: Derivation of $SZ$-model',
               1,
               'appendix:compartment_models',
               'appendix:compartment_models'),
              ('Guidelines for project submission',
               1,
               None,
               'guidelines-for-project-submission'),
              ('Bibliography', 1, None, 'bibliography')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="project4-readable.html">Random walking dead</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#sec:introduction" style="font-size: 80%;"><b>Introduction</b></a></li>
     <!-- navigation toc: --> <li><a href="#exercise-1-random-walk-sz-model" style="font-size: 80%;"><b>Exercise 1: Random walk \( SZ \)-model</b></a></li>
     <!-- navigation toc: --> <li><a href="#exercise-2-compare-random-walk-and-ode-based-models" style="font-size: 80%;"><b>Exercise 2: Compare random walk and ODE-based models</b></a></li>
     <!-- navigation toc: --> <li><a href="#exercise-3-scenario-what-happens-in-sokndal-and-dirdal" style="font-size: 80%;"><b>Exercise 3: Scenario what happens in Sokndal and Dirdal?</b></a></li>
     <!-- navigation toc: --> <li><a href="#exercise-4-compare-your-results-with-szr-model" style="font-size: 80%;"><b>Exercise 4: Compare your results with SZR model</b></a></li>
     <!-- navigation toc: --> <li><a href="#exercise-5-implement-your-own-scenario" style="font-size: 80%;"><b>Exercise 5: Implement your own scenario</b></a></li>
     <!-- navigation toc: --> <li><a href="#appendix:random_walk_suggestions" style="font-size: 80%;"><b>Appendix A: How to implement the random walk?</b></a></li>
     <!-- navigation toc: --> <li><a href="#appendix-b-speeding-up-the-code" style="font-size: 80%;"><b>Appendix B: Speeding up the code</b></a></li>
     <!-- navigation toc: --> <li><a href="#appendix:compartment_models" style="font-size: 80%;"><b>Appendix C: Derivation of \( SZ \)-model</b></a></li>
     <!-- navigation toc: --> <li><a href="#guidelines-for-project-submission" style="font-size: 80%;"><b>Guidelines for project submission</b></a></li>
     <!-- navigation toc: --> <li><a href="#bibliography" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<a name="part0000"></a>
<!-- ------------------- main content ---------------------- -->
<div class="jumbotron">
<center>
<h1>Random walking dead</h1>
</center>  <!-- document title -->

<!-- author(s): MOD510: Mandatory project \#4, and Deadline: 10. December (23:59) -->
<center>
<b>MOD510: Mandatory project \#4</b> 
</center>
<center>
<b>Deadline: 10. December (23:59)</b> 
</center>
<!-- institution(s) -->
<br>
<center>
<h4>Nov 13, 2023</h4>
</center> <!-- date -->
<br>

<center> <!-- figure label: --> <div id="fig:p3:wkd"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 1: Prepare for the worst (From the AMC show ''The Walking Dead'')  <!-- caption label: fig:p3:wkd --></p>
</center>
<p><img src="fig-project4/wkd.png" width="400" align="bottom"></p>
</center>

<p>
<b>Learning objectives.</b>
By completing this project, the student will:
</p>
<ul>
<li> Learn how to escape a zombie outbreak by modeling the outbreak as a random walk.</li>
<li> Use Monte Carlo techniques to quantify model uncertainty.</li>
<li> Investigate how model parameters in a continuum model can be predicted from random walk.</li>
<li> Get insight into mechanisms important for spread of infectious diseases.</li> 
</ul>

</div> <!-- end jumbotron -->
<h1 id="sec:introduction" class="anchor">Introduction</h1>

<p>In this project you are going to study the spread of a zombie outbreak in two Norwegian villages, Sokndal and Dirdal, using 
random walk simulations <a href="#triambak2021random">[1]</a> <a href="#codling2008random">[2]</a> <a href="#bailey1967simulation">[3]</a> <a href="#kelker1973random">[4]</a>. You will also compare your results with <a href="https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology" target="_self">classical compartment models</a> <a href="#kermack1927contribution">[5]</a>.
</p>

<p>The random-walk approach is an example of agent-based models <a href="#perez2009agent">[6]</a> <a href="#badham2018developing">[7]</a> <a href="#kerr2021covasim">[8]</a>,
in which each individual (or a small group of individuals) is represented explicitly.
Classical compartment models are much coarser, and do not seek to capture the behaviour of individuals.
Typically, they use ordinary differential equations (ODEs) to capture the dynamics of how
a disease spreads in the population.
</p>
<!--  -->
<!-- Compartment models can be either deterministic or stochastic. -->
<!-- While stochastic models are more realistic, they are also more challenging to use and interpret. -->
<!-- In this project, we consider the deterministic SI- and SIR-models. -->
<!--  -->
<!--  -->
<!-- As time goes by, people will change state depending on whom they meet, -->
<!-- but also partly due to chance. -->
<!--  -->
<p>Regardless of the approach taken, the total population can, at any given time, be partitioned
into compartments based on a set of possible "disease states", e.g., "Susceptible", "Infected (Zombie)",
"Recovered", and "Dead". 
The part that is different is how we model the "flow" of people from one compartment to another.
</p>

<div class="alert alert-block alert-success alert-text-normal"><b>Before we start:</b>
<p>In this project, more than any other, you have take care about numerical efficiency - your very future may depend on it!</p>
</div>


<center> <!-- figure label: --> <div id="fig:SI_model"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 2: The SZ-model: All individuals are either "Susceptible" or "Zombies". Once you become infected, there is no recovery.  <!-- caption label: fig:SI_model --></p>
</center>
<p><img src="fig-project4/ZI.png" width="800" align="bottom"></p>
</center>

<h1 id="exercise-1-random-walk-sz-model" class="anchor">Exercise 1: Random walk \( SZ \)-model </h1>

<p>To start out simple, we shall first consider the SZ-model depicted in figure <a href="#fig:SI_model">2</a>.
Later, we will extend the model by adding more compartments.
</p>

<p>For the random walk approach, the scenario we shall consider is that of
an isolated population in a restricted spatial area, e.g., an island,
a boat <a href="#WikiDiamondPrincess">[9]</a>, or a city surrounded by walls.
Specifically, we model the local geography with a 2-dimensional,
rectangular lattice composed of \( n_x\times{n_y} \) equally spaced nodes (figure <a href="#fig:rw">3</a>).
Each node represents a specific location, and during a simulation people
move <a href="https://en.wikipedia.org/wiki/Random_walk" target="_self">randomly</a> between neighbouring nodes.
</p>

<p>Each time step we shall require that all walkers move completely
randomly (i.e., with a 25 percent chance) in one of the following four
directions: North, South, East, or West.
That is, a walker goes <em>either</em> in the x-direction <em>or</em> in the y-direction,
but not both at the same time (diagonal moves are prohibited).
After walkers have moved, each human present at a location will
"encounter" every zombie at the same location and risk being bitten, scratched and exposed to the zombie virus. All zombies have the same probability, \( q \), of infecting a human. 
</p>

<p>Unless otherwise is noted explicitly, we will set \( n_x=n_y=50 \) and assume there are
\( N=683 \) people in the population. Also, the probability of getting infected is by
default assumed to be \( q=0.9 \).
</p>

<center> <!-- figure label: --> <div id="fig:rw"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 3: Example illustration of walkers moving on a lattice during one time step. In the plot, \( q \) is the probability that a walker is infected.  <!-- caption label: fig:rw --></p>
</center>
<p><img src="fig-project4/rw.png" width="800" align="bottom"></p>
</center>

<p>
<b>Task 1.(The most comprehensive task!)</b>
</p>

<ul>
<li> Write a class (or function) that can be used to conduct a single simulation of the random walk algorithm for the SZ-model.</li>
</ul>
<div class="alert alert-block alert-success alert-text-normal"><b>Read this before you start coding</b>
<p>We recommend that you look at <em>all</em> exercises before starting to code, because
it is expected that the final simulator you hand in can be used for every
scenario you model; that is, you will lose points if you make multiple solvers.
Since your program could become quite large, it is crucial that you include
sufficient documentation to your code. You can go a long way towards this goal
by choosing intuitive names for classes, functions, and variables
</p>

<p>For this particular exercise, you will get full marks as long as the \( SZ \)-model
works as intended. At minimum, your implementation of the SZ-model has to
perform the following steps:
</p>
<ol>
<li> At \( t=0 \), place walkers randomly on the \( n_x\times{n_y} \) rectangular lattice.</li>
<li> For each time step, update the position of all walkers, then:
<ol type="a"></li>
   <li> Check if they are at a legal position; for those that are not, revert back to previous position.</li>
   <li> For each S-Z encounter, check whether the healthy person was infected. If yes, update the disease state of the healthy individual from \( S \) to \( Z \).</li>
</ol>
<li> At any given time, calculate the total number of humans and zombies.</li>
<li> Keep track of the history of the number of walkers in each state since \( t=0 \) (e.g., by storing these numbers in a set of arrays).</li>
</ol>
<p>It is also a very good idea to create a function that plots the current
location of all walkers on the "map" with a scatter plot.
Use different colors to distinguish between walkers of different type
(e.g., humans, zombies, dead). However, such a function should not be automatically invoked at each time step,
because that will clutter your notebook with figures.
A good default could be to plot every \( n \)-th timestep where \( n \) is "large enough",
or to require the user to specifically input specific time steps at which to
visualize the map.
</p>

<p>If you want, you can place your simulation class (or function) into a separate
.py file, and simply <a href="https://docs.python.org/3/tutorial/modules.html" target="_self">import it</a>
at the top of your Jupyter notebook.
</p>
</div>


<div class="alert alert-block alert-success alert-text-normal"><b>Consult the Appendix for further help</b>
<p>The appendices at the back contain suggestions for how you can structure your
code so that it becomes easy to extend your model with additional compartments.
In particular, Appendix B contains tips on how to make an efficient
implementation.The random walk simulations are very CPU-intensive, thus speed
matters in this project! 
</p>
</div>


<p>
<b>Question 1:</b>
Assume that there is a single zombie initially, \( Z(0) \) = 1, what is the fate of the zombie and human population? (Figure <a href="#fig:p4:rwN">4</a> gives an indication of what we expect as an answer.)
</p>

<p>
<b>Possible approach:</b>
</p>
<ul>
<li> Run the (default) random walk SZ-model forward in time repeatedly; at least 100 times. For each run, take 300 time steps. (If your code is fast, you should experiment with running the code even more times, and longer if necessary)</li>
<li> For each time step, calculate 1) the sample mean and 2) the sample standard deviation of the number of humans (S) and zombies (Z) in the population.</li>
<li> Create a figure showing the expected time-development of the two populations. Make sure to include the computed uncertainty in the figure.</li>
</ul>
<center> <!-- figure label: --> <div id="fig:p4:rwN"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 4: Left: average of 10 simulations of the random walk \( SZ \)-model. Right: average of 100 simulations. The gray shaded lines represent plus/minus one standard deviation.  <!-- caption label: fig:p4:rwN --></p>
</center>
<p><img src="fig-project4/SI_comb_rw.png" align="bottom"></p>
</center>

<p><em>Coding tip</em>: To visualize the uncertainty, the above plots used the <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.fill_between.html" target="_self"><tt>fill_between</tt></a>. function in <code>matplotlib</code>.</p>

<p>
<b>Question 2:</b>
If we instead started with \( Z(0)=10 \), how does the time evolution change?
</p>
<h1 id="exercise-2-compare-random-walk-and-ode-based-models" class="anchor">Exercise 2: Compare random walk and ODE-based models </h1>

<p>The ODE-based, deterministic SZ-model is:</p>
$$
\begin{align}
\tag{1}
\frac{\mathrm{d}S(t)}{\mathrm{d}t} &= -\beta(t)\cdot\frac{S(t)Z(t)}{N}\\ 
\tag{2}
\frac{\mathrm{d}Z(t)}{\mathrm{d}t}&=\beta(t)\cdot\frac{S(t)Z(t)}{N}\,,
\end{align}
$$

<p>where \( S(t) \) is the number of humans (susceptible) at time \( t \),
\( Z(t) \) denotes the number of zombies and \( N=S(t)+Z(t) \) is the total population size. \( \beta \) can be viewed an effective contact (disease transmission) rate;
the total number of effective contacts made by any individual per unit time,
multiplied with the probability of infection.
The actual rate at which susceptible individuals become infected are
given by the product \( \beta(t)Z(t)/N \), sometimes referred 
to as the <em>force of infection</em>. 
See  <a href="#appendix:compartment_models">Appendix C: Derivation of \( SZ \)-model</a> for a detailed mathematical derivation of the \( SZ \)-model.
</p>

<p>If we assume a constant \( \beta \), the analytical solution is</p>
$$
\begin{align}
\tag{3}
Z(t)&=\frac{N}{1+\frac{S_0}{Z_0}\exp(-\beta{t})}\,,
\end{align}
$$

<p>where \( S_0=S(0) \) is the number of healthy people at \( t=0 \), and \( Z_0=Z(0) \).</p>

<div class="alert alert-block alert-success alert-text-normal"><b>How to interpret \( \beta \)?</b>

<p>If we assume that \( \beta \) is constant, we are making several <em>very strong</em>
assumptions:
</p>

<ul>
<li> Humans make the same number of contacts regardless of the population size.</li>
<li> Humans make the same number of contacts independent of time.</li>
<li> The probability of becoming infected never changes.</li>
</ul>
<p>In reality, \( \beta \) is strongly time-dependent and accounts for a lot of
biomedical, physical, and sociological factors.
For example, in the beginning of an outbreak, \( \beta \) is likely to be large,
because people might not yet understand the severity of the situation,
or they may be in denial.
As people start to realize the danger and fight back against the disease, 
\( \beta \) will most likely decrease.
However, as we have seen with COVID-19, new strains of the virus may appear
and cause transmission rates to go up again.
Another complication is that people perceive the threat from the virus very
differently, and at least in some countries, this seems to be influenced
by political factors.
</p>
</div>


<p>
<b>Question 1:</b>
How does your Monte Carlo random walk prediction compare with the continuum (ODE) model in equation <a href="#mjx-eqn-3">(3)</a>? (To answer this question you need to estimate \( \beta \) from the random walk simulation and apply your estimate of \( \beta \) in equation <a href="#mjx-eqn-3">(3)</a> and compare the two simulations).  
</p>

<p>
<b>How to estimate \( \beta \):</b>
Consider the random walk simulations conducted in Exercise 1, Part 1 with \( Z(0)=10 \).
We wish to find a representative \( \beta \) based on the results ("observations").
For a given simulation, we combine equation <a href="#mjx-eqn-1">(1)</a> with a first order approximation
of the derivative to yield
</p>
$$
\begin{equation}
\tag{4}
\beta_n\cdot\Delta t \approx -\frac{(S(t_n)-S(t_n-\Delta t))N}{S(t_n)Z(t_n)}
=-\frac{(S_n-S_{n-1})N}{S_n Z_n}\,,
\end{equation}
$$

<p>where \( \beta_n \) is an estimate for \( \beta(t) \) at the end of the \( n \)-th time step, \( t_n=n\Delta{t} \), \( n=1, 2, \ldots \).</p>
<p>
<b>Possible approach to get representative \( \beta \):</b>
</p>
<ul>
<li> For each run of the random walk model and every time step \( n>=1 \), calculate \( \beta_n\Delta t \) using equation <a href="#mjx-eqn-4">(4)</a>.</li>
<li> Use the resulting 2D array of values to find a single, representative (constant) \( \beta \). You could to this, e.g., by calculating an appropriate mean or median value.</li>
<li> Apply the analytical SZ-model, equation <a href="#mjx-eqn-1">(1)</a>, with the \( \beta \) you just found. Compare it to the mean number of infected individuals from the random walk simulations.</li>
</ul>
<p>Alternatively, you could try to construct a non-constant function \( \beta=\beta(t) \) based on the
random walk data. However, then you need to find another solution to the ODE-system <a href="#mjx-eqn-1">(1)</a>-<a href="#mjx-eqn-2">(2)</a>,
because equation <a href="#mjx-eqn-1">(1)</a> is no longer valid.
</p>
<!--  -->
<!-- However, we can continue to use equation <a href="#mjx-eqn-1">(1)</a>, provided we replace the product \( \beta t \) -->
<!-- with the definite integral \( \int_0^t \beta(t)dt \)... -->
<!--  -->

<div class="alert alert-block alert-success alert-text-normal"><b>Remark on the time scale in the random walk algorithm</b>
<p>The time scale is determined from the number of susceptible-infectious
encounters per time unit. Thus, in the random walk simulations we can only
determine the product \( \beta\Delta t_\text{RW} \). If we have data available on
the spread of the disease, we can use the data to determine
\( \beta \) after which we can estimate \( \Delta t_\text{RW} \).
</p>
</div>

<!--  -->
<!-- For the specific case in which \( \beta(t)=\beta_0 e^{-\lambda t} \) for two constants \( \beta_0 \) and \( lambda \)... -->
<h1 id="exercise-3-scenario-what-happens-in-sokndal-and-dirdal" class="anchor">Exercise 3: Scenario what happens in Sokndal and Dirdal? </h1>

<center>  <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 5: A view from Sokndal (left) and Dirdal (right).</p>
</center>
<p><img src="fig-project4/sd.png" width="400" align="bottom"></p>
</center>

<p>Sokndal and Dirdal are two small villages in Rogaland. A group of 10 scientists from each of these places went to an international conference on numerical methods
in Haiti <button type="button" class="btn btn-primary btn-xs" rel="tooltip" data-placement="top" title="Maybe the most unlikely part of this project is that small villages in Norway have this many mathematicians ..."><a href="#def_footnote_1" id="link_footnote_1" style="color: white">1</a></button>. During the conference, an excursion was arranged to a rural area,
and a strange tomato salad consisting of, among other things, pufferfish
venom, was served <a href="#davis2010serpent">[10]</a>.
After arriving back in Norway, both groups of scientists got a fever, stopped eating,
and subsequently started to behave suspiciously ...
</p>

<p id="def_footnote_1"><a href="#link_footnote_1"><b>1:</b></a> Maybe the most unlikely part of this project is that small villages in Norway have this many mathematicians ...</p>

<p>Dirdal has about 683 inhabitants, and for sake of simplicity we will assume that the city center of Sokndal has a similar amount of 683 inhabitants <a href="#snl">[11]</a>.</p>

<p>At a certain point the inhabitants in the two villages can no longer ignore what is going on, and to avoid the coming zombie apocalypse, measures are taken. However, the time of realization and call for arms are different in the two villages.    </p>

<div class="alert alert-block alert-success alert-text-normal"><b>Sokndal versus Dirdal?</b>
<p>In Sokndal, the average life expectancy of a zombie is about 24 hours. In Dirdal, it is about 48 hours.
One explanation for this is that the inhabitants of Dirdal are more tolerant
of unorthodox behavior, with the consequence that it takes more time for them
to discover the zombies. However, anecdotal evidence suggests that people in
Sokndal behave in quite strange ways also, as might be inferred from the
lyrics of their local singer-songwriter T&#248;nes.
</p>
</div>


<p>
<b>Question 1:</b>
Assume an average life expectancy of zombies of 48 (hours) and 24 (hours) <button type="button" class="btn btn-primary btn-xs" rel="tooltip" data-placement="top" title="Note that we implicitly assume that one iteration in the Monte Carlo simulation is 1 hour."><a href="#def_footnote_2" id="link_footnote_2" style="color: white">2</a></button> in Dirdal and Sokndal respectively. What happens in the two villages?
</p>

<p id="def_footnote_2"><a href="#link_footnote_2"><b>2:</b></a> Note that we implicitly assume that one iteration in the Monte Carlo simulation is 1 hour.</p>

<p>
<b>Question 2:</b>
For future zombie attacks: What is approximately the highest life expectancy of zombies, where humans still survive?
</p>

<p>
<b>How to extend your code:</b>
Zombies have a certain life expectancy due to being attacked by planes, cars, guns or simply that they die due to stupidity. The key point is that they do not necessarily die because of  human-zombie interaction, thus over the time of simulation a zombie can die without being close to another human.
</p>

<ul>
<li> Extend your random walk implementation to handle the zombie deaths. By default, assume that no zombies dies, \( p_\text{death}=0 \), thus recovering the \( SZ \)-model.</li>
</ul>
<p><em>Coding tip</em>: At each time iteration, and for each zombie, pick a random number, \( x\in [0,1] \), if \( x < p_\text{death} \), update the state of the zombie to a dead state. (If you make plots at regular intervals, it looks cooler if the dead zombies do not move, and that they have a different color.)</p>

<p><em>Remember to take advantage of vectorization, you can draw a random number between zero and one for all zombies in one go.</em>  </p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #3D7B7B; font-style: italic">#pseudo code</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nstep): <span style="color: #3D7B7B; font-style: italic">#Nstep: total time steps in one simulation</span>
    move_walkers()
    set_back_illegal_moves()
    check_for_infection()
    check_if_zombies_dies()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>
<b>Possible approach to answer the questions:</b>
Run the Sokndal case with \( p_\text{death}=1/24 \), and Dirdal with \( p_\text{death}=1/48 \).
</p>
<ul>
<li> What happens in the two villages? You need to run multiple simulations and present the average and standard deviation to get a reasonable picture.</li>
<li> Play around with other values of \( p_\text{death} \), what is approximately the highest life expectancy of zombies, where humans still survive?</li>
</ul>
<h1 id="exercise-4-compare-your-results-with-szr-model" class="anchor">Exercise 4: Compare your results with SZR model </h1>

<p>
<b>Question 1:</b>
How does your predictions in the previous exercise compare with a continuum (ODE) model? 
</p>

<p>
<b>To get you started:</b>
The corresponding ODE model is  
</p>

$$
\begin{align}
\tag{5}
\frac{\mathrm{d}S(t)}{\mathrm{d}t}&=-\beta(t)\cdot\frac{S(t)Z(t)}{N}\\ 
\tag{6}
\frac{\mathrm{d}Z(t)}{\mathrm{d}t}&=\beta(t)\cdot\frac{S(t)Z(t)}{N}-\frac{1}{\tau_\text{death}}\cdot Z(t)\\ 
\tag{7}
\frac{\mathrm{d}R(t)}{\mathrm{d}t}& = \frac{1}{\tau_\text{death}}\cdot Z(t)\,,
\end{align}
$$

<p>where \( R(t) \) is the number of "Removed" individuals or dead zombies at time \( t \) and
\( \tau_\text{death} \) represents the mean life time of zombies. If \( \tau_\text{death}\to\infty \), a zombie lives forever, and equations <a href="#mjx-eqn-5">(5)</a>-<a href="#mjx-eqn-7">(7)</a> reduce to the \( SZ \)-model.
</p>

<p>
<b>Possible approach:</b>
</p>
<ul>
<li> As before estimate \( \beta \) and \( \tau_\text{death} \) from the random walk simulations (i.e. use equation <a href="#mjx-eqn-4">(4)</a> and <a href="#mjx-eqn-8">(8)</a>.)</li>
<li> To get representative results, make sure you conduct many model runs. Plot the average number of susceptible, zombies and dead (removed) as a function of time. Visualize the uncertainty in your plots.</li>
</ul>
<p>In figure <a href="#fig:p4:SIRrw">6</a> a typical result is shown, when values for \( \beta \) and \( \tau \) are used in the ODE model.</p>

<center> <!-- figure label: --> <div id="fig:p4:SIRrw"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 6: SZR Random walk model and comparison with ODE compartment model.  <!-- caption label: fig:p4:SIRrw --></p>
</center>
<p><img src="fig-project4/SI_rw4.png" width="400" align="bottom"></p>
</center>

<p>The following code provides an implementation of the deterministic \( SIR \)-model 
(along with necessary package imports, which you should place at the top of your notebook):
</p>


<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.integrate</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">SZR_model</span>(t, <span style="color: #666666">*</span>, beta, tau_s, N<span style="color: #666666">=683</span>, Z0<span style="color: #666666">=1</span>, R0<span style="color: #666666">=0</span>):

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">rhs</span>(X, t):
        S, Z, R <span style="color: #666666">=</span> X
        <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #666666">-</span>beta<span style="color: #666666">*</span>S<span style="color: #666666">*</span>Z<span style="color: #666666">/</span>N, <span style="color: #666666">+</span>beta<span style="color: #666666">*</span>S<span style="color: #666666">*</span>Z<span style="color: #666666">/</span>N <span style="color: #666666">-</span> Z<span style="color: #666666">/</span>tau_s, <span style="color: #666666">+</span>Z<span style="color: #666666">/</span>tau_s]

    X0 <span style="color: #666666">=</span> [N<span style="color: #666666">-</span>Z0<span style="color: #666666">-</span>R0, Z0, R0]
    sol <span style="color: #666666">=</span> integrate<span style="color: #666666">.</span>odeint(rhs, X0, t)
    <span style="color: #008000; font-weight: bold">return</span> sol
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>To estimate \( \tau_\text{death} \) from the simulations you can do</p>

$$

\begin{equation}
\frac{\Delta t}{\tau_\text{death}}=\frac{R_{n}-R_{n-1}}{Z_n},
\tag{8}
\end{equation}
$$

<p>where \( R_n \) is the number of dead zombies at time \( t_n \). </p>
<h1 id="exercise-5-implement-your-own-scenario" class="anchor">Exercise 5: Implement your own scenario </h1>

<p>For the final part of the project, you are going to implement your own scenario.
Below are some possible avenues for you to explore:
</p>

<ul>
<li> Let \( p_\text{death}=0 \) and the only way to remove zombies is by human zombie interactions. E.g. whenever a human survives an attack, the zombie die. Here you can also decrease the probability of that human to be infected at the next encounter (by e.g. reducing the probability of infection to 50$\%$). To make this work you need an array describing infection probability for each human.</li>
<li> Let some people be immune to the disease, and investigate how large part of the population should be immune for most to survive a zombie apocalypse. (Here you need to keep \( p_\text{death}>0 \))</li>
<li> Distinguish between old and young people. Let older people have a larger probability of dying. You can also let the old population have a probability of not moving at all during a time step, and/or to only move in a selected area (presumably, near "home").</li>
<li> For those that have seen Walking Dead, you might try to add that those people that are good at killing zombies also get more dangerous and kill other humans.</li>  
</ul>
<p>Clearly, there are infinitely many choices you may make when it comes to
model features, both individually and in combination. Therefore, it is very
important that you state your assumptions carefully when presenting your 
scenario, and that you document your code accordingly.
</p>

<p>It is also crucial that you illustrate your findings with one or more figures,
and that you discuss how your model scenario compares to the previously 
investigated cases.
</p>

<p>If you are able to relate your scenario to <em>the real world</em> (e.g., by comparing
to relevant empirical data or movies), you can score some bonus points on this exercise!
</p>
<h1 id="appendix:random_walk_suggestions" class="anchor">Appendix A: How to implement the random walk?</h1>

<p>As in project 2, we strongly recommend that you create a single
simulator class responsible for running your model from start to finish.
This allows different class functions to re-use the same variables,
instead of having to pass them around all the time. At the same time,
you avoid using global variables, which can be a source of hard-to-find bugs,
and make your program hard to understand.
Another advantage of using classes is that it becomes trivially simple to
conduct parallell simulation runs, using either identical or variable model
input parameters, which will be needed for this project.
</p>

<p>Below is a suggestion for how you may start writing the <code>__init__</code> method
of such a class:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">RandomWalkEpidemicSimulator</span>:
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Class used to model the spreading of a contagious disease in a</span>
<span style="color: #BA2121; font-style: italic">    population of individuals with a 2D random walk.</span>

<span style="color: #BA2121; font-style: italic">    Each walker has a disease state which is represented by an</span>
<span style="color: #BA2121; font-style: italic">    integer Enum. Also, a set of integer (x, y)-coordinates are</span>
<span style="color: #BA2121; font-style: italic">    stored for each walker. The possible coordinates are:</span>

<span style="color: #BA2121; font-style: italic">        {0, 1, ..., Lx-1} in the x-direction</span>
<span style="color: #BA2121; font-style: italic">        {0, 1, ..., Ly-1} in the y-direction</span>

<span style="color: #BA2121; font-style: italic">    It is only possible to move North, South, East, or West. If a</span>
<span style="color: #BA2121; font-style: italic">    walker attempts to move outside of the physical domain, nothing</span>
<span style="color: #BA2121; font-style: italic">    happens (i.e., a &quot;bounce-back boundary condition&quot; is enforced).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>,
                 population_size,
                 no_init_infected<span style="color: #666666">=1</span>,
                 nx<span style="color: #666666">=50</span>,
                 ny<span style="color: #666666">=50</span>,
                 q<span style="color: #666666">=0.9</span>):
<span style="color: #bbbbbb">        </span><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        :param population_size: The total number of people (N).</span>
<span style="color: #BA2121; font-style: italic">        :param no_init_infected: The number of infected people at t=0.</span>
<span style="color: #BA2121; font-style: italic">        :param nx: The number of lattice nodes in the x-direction</span>
<span style="color: #BA2121; font-style: italic">        :param ny: The number of lattice nodes in the y-direction.</span>
<span style="color: #BA2121; font-style: italic">        :param q: The probability of infection (0 &lt;= q &lt;= 1).</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>N_ <span style="color: #666666">=</span> population_size
        <span style="color: #008000">self</span><span style="color: #666666">.</span>Z0_<span style="color: #666666">=</span> no_initially_infected
        <span style="color: #008000">self</span><span style="color: #666666">.</span>nx_<span style="color: #666666">=</span> nx
        <span style="color: #008000">self</span><span style="color: #666666">.</span>ny_<span style="color: #666666">=</span> ny
        <span style="color: #008000">self</span><span style="color: #666666">.</span>infection_probability_ <span style="color: #666666">=</span> q
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>As you work through the project, you will gradually add more content to the
class; inside the <code>__init__</code> function, as well as in other functions.
</p>
<h3 id="position-of-walkers" class="anchor">Position of Walkers </h3>

<p>At each time step, we need to know the positions of all walkers.
This becomes simple if we store the walker \( (x,y) \)-coordinates in
a 2D NumPy array. To generate random starting positions, we simply
draw one \( x \)-coordinate and one \( y \)-coordinate for each walker:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_ <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>randint(<span style="color: #666666">0</span>,
                                  [<span style="color: #008000">self</span><span style="color: #666666">.</span>nx_, <span style="color: #008000">self</span><span style="color: #666666">.</span>ny_],
                                  size<span style="color: #666666">=</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>N_, <span style="color: #666666">2</span>))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>To understand what the code does, choose some small values for \( n_x \), \( n_y \),
and \( N \), and inspect the result.
</p>
<h3 id="move-walkers" class="anchor">Move walkers </h3>

<p>It is important that the walkers move <em>randomly</em>, and only one step in
<em>either</em> the \( x \)- <em>or</em> the \( y \)-direction. There are many ways to achieve this.
One method is to draw a random integer \( u \) between 1 and 4, and to say, e.g.:
</p>
<ul>
<li> If <code>u==1</code>, move East: add \( [1, 0] \) to the \( (x, y) \)-coordinates,</li>
<li> If <code>u==2</code>, move North: add \( [0, 1] \),</li>
<li> If <code>u==3</code>, move West: add \( [-1, 0] \),</li>
<li> If <code>u==4</code>, move South: add \( [0, -1] \).</li>
</ul>
<p>As an example, suppose we have five walkers and moreover that we have
already drawn the following (random) steps:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">next_steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>]])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>According to the scheme proposed above, these steps corresponds to the
first and fourth walkers moving North, the second and third moving East,
and the fifth moving South.
Since all directions are stored in array of the same size as the population,
we can update the walker positions simultaneously with a simple addition:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_ <span style="color: #666666">+=</span> next_steps
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>An alternative method is to update each of the four directions separately.
A situation where this could be relevant is when we have drawn the random
integers representing directions, but have not yet converted
them into \( (x, y) \)-coordinate changes:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">proposed_directions <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>We can use
<a href="https://jakevdp.github.io/PythonDataScienceHandbook/02.06-boolean-arrays-and-masks.html" target="_self">boolean masking</a>
to find out which walkers move in which direction:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">move_east <span style="color: #666666">=</span> (proposed_directions <span style="color: #666666">==</span> <span style="color: #666666">1</span>)
move_north <span style="color: #666666">=</span> (proposed_directions <span style="color: #666666">==</span> <span style="color: #666666">2</span>)
move_west <span style="color: #666666">=</span> (proposed_directions <span style="color: #666666">==</span> <span style="color: #666666">3</span>)
move_south <span style="color: #666666">=</span> (proposed_directions <span style="color: #666666">==</span> <span style="color: #666666">4</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Finally, we update the coordinates:</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">Walkers_[move_east] <span style="color: #666666">+=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
Walkers_[move_west] <span style="color: #666666">-=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">0</span>]
Walkers_[move_north] <span style="color: #666666">+=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
Walkers_[move_south] <span style="color: #666666">-=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h3 id="revert-illegal-moves-bounce-back-condition" class="anchor">Revert illegal moves (Bounce-back condition)  </h3>

<p>Before checking for new infections, we need to make sure that none of the
walkers are outside of the grid. We can achieve this by
keeping track of walker coordinates from the previous time step:
For each walker, we check whether that walker is at a legal position;
if not, revert back to the old coordinates. This is often called
a <em>bounce-back boundary condition</em>.
</p>

<p>To extract the old \( (x,y) \)-coordinates, we can type:</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_Old_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_<span style="color: #666666">.</span>copy()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Note the use of <code>copy()</code> here. If we had written</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_Old_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_  <span style="color: #3D7B7B; font-style: italic"># Wrong code!!!</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>it would not work, because arrays are
<a href="https://towardsdatascience.com/https-towardsdatascience-com-python-basics-mutable-vs-immutable-objects-829a0cb1530a" target="_self">mutable</a>
objects in Python.
This means that if <code>Walkers_</code> had been assigned directly to <code>Walkers_Old</code>,
both variable names would point to the same underlying object in memory.
Since the arrays contain objects of an immutable type (<code>int</code>), one way to avoid
this problem is to create a shallow copy with <code>copy()</code>. In other situations,
a <a href="https://realpython.com/copying-python-objects/" target="_self"><tt>deepcopy()</tt></a> operation might
be needed; e.g., if we stored objects of a custom class in the <code>Walkers_</code> array
(instead of integers).
</p>

<p>To check for legal positions, the most obvious thing to do is to use a for loop:</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #3D7B7B; font-style: italic"># Note: Assumes we have already created a class (instance) function</span>
<span style="color: #3D7B7B; font-style: italic">#       &quot;is_at_illegal_position&quot; that checks whether the coordinates</span>
<span style="color: #3D7B7B; font-style: italic">#       of a given walker is valid.</span>
<span style="color: #008000; font-weight: bold">for</span> idx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>N_):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>is_at_illegal_position(idx):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_[idx] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_Old_[idx]

<span style="color: #3D7B7B; font-style: italic"># Remember to save the new positions for the next time step</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_Old_ <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_<span style="color: #666666">.</span>copy()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>However, this method is likely to be very slow. Instead you might want to use
<a href="https://jakevdp.github.io/PythonDataScienceHandbook/02.06-boolean-arrays-and-masks.html" target="_self">boolean masking</a>
to correct the position of each walker without using for loops.
See Appendix B for more details.
</p>

<center> <!-- figure label: --> <div id="fig:bb"></div> <!-- FIGURE -->
<hr class="figure">
<center>
<p class="caption">Figure 7: An illustration of the bounce-back boundary condition. The wall is located to the east, and a move in the east direction is illegal.  <!-- caption label: fig:bb --></p>
</center>
<p><img src="fig-project4/bb.png" width="300" align="bottom"></p>
</center>

<h3 id="state-of-walkers" class="anchor">State of Walkers </h3>

<p>We still have no information about the state (susceptible, infected, recovered, dead, etc.)
of each individual walker.
To handle this, we suggest introducing a set of <em>named integer constants</em>.
These could for example be members of the simulator class
(either class attributes or instance attributes), e.g.:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>HUMAN <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>ZOMBIE <span style="color: #666666">=</span> <span style="color: #666666">1</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>DEAD <span style="color: #666666">=</span> <span style="color: #666666">2</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Alternatively, they could be stored in a separate
<a href="https://docs.python.org/3/library/enum.html" target="_self">enumeration class</a>:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">enum</span> <span style="color: #008000; font-weight: bold">import</span> Enum
<span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">DiseaseState</span>(Enum):

    HUMAN <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    ZOMBIE <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    DEAD <span style="color: #666666">=</span> <span style="color: #666666">2</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>The following example shows how you can use this kind of approach in your code:</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #3D7B7B; font-style: italic"># First, let all walkers be in the susceptible compartment:</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>State_ <span style="color: #666666">=</span> np<span style="color: #666666">.</span>full(<span style="color: #008000">self</span><span style="color: #666666">.</span>N_, <span style="color: #008000">self</span><span style="color: #666666">.</span>HUMAN)
<span style="color: #3D7B7B; font-style: italic"># Next, change walker number 0, 1, 2, ..., I0-1 to be infectious:</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>State_[<span style="color: #666666">0</span>:<span style="color: #008000">self</span><span style="color: #666666">.</span>Z0_] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>ZOMBIE
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>As the simulation is progressing, the <code>State_</code> array will be continually updated.
At any given time, we can count the total number of infected, recovered etc.
by
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">no_susceptible <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(<span style="color: #008000">self</span><span style="color: #666666">.</span>State_ <span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>HUMAN)
no_infectious <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(<span style="color: #008000">self</span><span style="color: #666666">.</span>State_ <span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>ZOMBIE)
no_recovered <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(<span style="color: #008000">self</span><span style="color: #666666">.</span>State_ <span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>DEAD)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>When using named integers (Enums), the code becomes much easier to read than
if you work with hard-coded integers; it means you will never have to
remember that <code>0=HUMAN</code> and <code>1=ZOMBIE</code> etc..
Also, the approach can easily handle the addition of more compartments,
or changing the numbering scheme later on. For instance, suppose
you want to use to the following numbering instead:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>HUMAN <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>EXPOSED <span style="color: #666666">=</span> <span style="color: #666666">1</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>ZOMBIE <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>IMMUNE <span style="color: #666666">=</span> <span style="color: #666666">3</span>
<span style="color: #008000">self</span><span style="color: #666666">.</span>DEAD <span style="color: #666666">=</span> <span style="color: #666666">4</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>If you wrote your code referring directly to the integers, you would have
to change each occurrence of <code>1</code> to <code>2</code>, and each occurence of <code>2</code> to <code>3</code>.
Obviously, this is much more error-prone than the Enum-approach.
</p>
<h3 id="checking-for-new-infections" class="anchor">Checking for new infections </h3>

<p>The "collision step" is crucial for performance.
A naive implementation would be something like the following:
</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">collide_extremely_slowly</span>(<span style="color: #008000">self</span>): <span style="color: #3D7B7B; font-style: italic"># note: class (instance) function</span>
<span style="color: #bbbbbb">    </span><span style="color: #BA2121; font-style: italic">&#39;&#39;&#39;</span>
<span style="color: #BA2121; font-style: italic">    Note: SUSCEPTIBLE = HUMAN, and INFECTIOUS = ZOMBIE</span>
<span style="color: #BA2121; font-style: italic">    This code is so slow that it will be impractical to use in the full project.</span>
<span style="color: #BA2121; font-style: italic">    You can use it to test your code. HINT: Try to use np.logical_and to find humans</span>
<span style="color: #BA2121; font-style: italic">    at	the same place as zombies, instead of the loop: for walker_idx in range(self.N_):</span>
<span style="color: #BA2121; font-style: italic">    &#39;&#39;&#39;</span>

    <span style="color: #3D7B7B; font-style: italic"># Get (x,y)-coordinates of susceptibles &amp; infectious people</span>
    S_coord <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_[<span style="color: #008000">self</span><span style="color: #666666">.</span>State_<span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>SUSCEPTIBLE_]
    I_coord <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_[<span style="color: #008000">self</span><span style="color: #666666">.</span>State_ <span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>INFECTIOUS_]

    no_infected <span style="color: #666666">=</span> <span style="color: #008000">len</span>(I_coord)
    <span style="color: #008000; font-weight: bold">for</span> infected_idx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(no_infected):
        <span style="color: #008000; font-weight: bold">for</span> walker_idx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>N_):
            walker_is_susceptible <span style="color: #666666">=</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>State_[walker_idx] <span style="color: #666666">==</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>SUSCEPTIBLE_)
            infected_at_same_location <span style="color: #666666">=</span> np<span style="color: #666666">.</span>all(I_coord[infected_idx] <span style="color: #666666">==</span> Walkers_[walker_idx])

            <span style="color: #008000; font-weight: bold">if</span> walker_is_susceptible <span style="color: #AA22FF; font-weight: bold">and</span> infected_at_same_location:
                q <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">if</span> q <span style="color: #666666">&lt;</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>infection_probability_:
                    <span style="color: #008000">self</span><span style="color: #666666">.</span>State_[walker_idx] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>INFECTIOUS_
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>With the above approach, we are doing a lot of superfluous
checks, every single time step of every simulation.
In the best case scenario, we are checking each walker once every time
step (this happens when there is a single infected person).
In the worst case scenario, when everyone is infected, we are checking \( N^{2} \)
combinations of walkers. With \( N=683 \), this means we are doing 466489
comparisons each and every time step! Obviously, this is not feasible.
</p>

<p>The strategy of starting by looping over infected individuals
is probably smart, however; at least initially, when there are few of them.
However, you will need to avoid doing pointless checks.
</p>
<h1 id="appendix-b-speeding-up-the-code" class="anchor">Appendix B: Speeding up the code </h1>

<p>To save time, you should only re-run simulations when you have to.
Be careful that you do not perform unnecessary tasks inside the main simulation
loop; for example, most plots and statistical calculations should be done after
finishing the simulations, outside of the main solver.
To be able to do that, you will need to store selected simulation results.
It might be helpful to store some data into text files for later retrieval
and post-processing.
</p>

<p>That said, a good rule is to <em>never optimize code too early</em>; first, make sure
the implementation works as expected, without thinking too much about
performance. Later on, you might find out that the code runs too slowly and
then you can try to fix that.
Below are some tips on what could be improved.
</p>

<ul>
<li> It is important to avoid loops whenever possible. For instance, drawing random numbers one at a time inside a loop tends to be <a href="https://eli.thegreenplace.net/2018/slow-and-fast-methods-for-generating-random-integers-in-python/" target="_self">very slow</a>:</li>
</ul>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, N):
        x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, d)
        y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, d)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Instead, take advantage of built-in functionality in Numpy to draw all the numbers at once:</p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, d, size<span style="color: #666666">=</span>N)
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, d, size<span style="color: #666666">=</span>N)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<ul>
<li> When locating walkers at illegal positions, or finding positions where infectious and susceptible individuals meet (this step is crucial for speed!), consider using <a href="https://numpy.org/doc/stable/reference/generated/numpy.where.html" target="_self"><tt>numpy.where</tt></a>.</li>
<li> You can also use <a href="https://jakevdp.github.io/PythonDataScienceHandbook/02.06-boolean-arrays-and-masks.html" target="_self">boolean masking</a>, for example:</li>
</ul>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">too_large_x <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_[:, <span style="color: #666666">0</span>] <span style="color: #666666">&gt;=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>nx_
too_small_x <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_[:, <span style="color: #666666">0</span>] <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
wrong_x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>logical_or(too_large_x,too_small_x)
<span style="color: #3D7B7B; font-style: italic"># alternatively you can use</span>
wrong_x <span style="color: #666666">=</span> too_large_x <span style="color: #666666">|</span> too_small_x  <span style="color: #3D7B7B; font-style: italic"># boolean &quot;OR&quot; applied elementwise</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<ul>
<li> Another example: Suppose we have created a boolean array of size <code>N_</code> called <code>at_illegal_pos</code>, where an entry is True iff the corresponding walker is outside the grid. Then, we can correct the illegal moves in a single line without a loop:</li>
</ul>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_[at_illegal_pos] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>Walkers_Old_[at_illegal_pos]
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<ul>
<li> <a href="https://numba.pydata.org/" target="_self">Numba</a> translates python functions to optimized machine code, and might be something to look into.</li>
</ul>
<p>A final tip (that might prove wrong)</p>

<ul>
<li> While it is often smart to use classes, avoid creating too many of them. For example, it might be tempting to represent individual walkers with a class, but our guess is that this will slow down the code considerably unless one is very careful. Accessing a class and its members adds extra overhead, which is why we prefer the approach of using arrays to hold information about the walkers.</li>
</ul>
<h1 id="appendix:compartment_models" class="anchor">Appendix C: Derivation of \( SZ \)-model</h1>

<p>To derive equation <a href="#mjx-eqn-1">(1)</a> in the main text, we start by making some observations:</p>
<ul>
<li> During each time interval \( \Delta{t} \), a certain number of individuals will come into contact with each other.</li>
<li> We only care about susceptible (human) - zombie (infected) encounters, because that is the only scenario in which the number of infected people can increase.</li>
<li> Whenever a healthy person meets an infected person, there is a certain probability that the healthy person becomes infected.</li>
</ul>
<p>We shall take our imagined population to be <em>well mixed</em>,
meaning that pairs of individuals interact with equal probability.
Let \( \mathcal{C}(N) \) denote the rate at which <em>any</em> individual in the
population contacts <em>any</em> another individual, i.e., the average number of
contacts made per unit time. We calculate the change in the healthy
population from time \( t \) to \( t+\Delta{t} \) from
</p>
$$
\begin{align}
S(t+\Delta t)-S(t) = -\mathcal{C}(N)\cdot{\Delta t}
\cdot{p}\cdot{q}\cdot{S(t)}\,,
\tag{9}
\end{align}
$$

<p>where \( p \) denotes the conditional probability that a given contact is
between a susceptible and infected individual, and \( q \) is the probability
that such an encounter leads to disease transmission.
Because of the well-mixed condition, we set \( p=Z(t)/N \).
The remaining challenge is to estimate \( \mathcal{C}(N) \) and \( q \).
By merging the two factors into a single parameter, \( \beta=\beta(t) \), we get
</p>
$$
\begin{align}
S(t+\Delta t)-S(t) = -\beta(t)\cdot{\Delta t}\cdot\frac{S(t)Z(t)}{N}\,,
\tag{10}
\end{align}
$$

<p>Finally, by dividing by \( \Delta t \) and letting \( \Delta t \rightarrow 0 \),
we obtain the following ordinary differential equation (ODE):
</p>
$$
\begin{align}
\tag{11}
\frac{\mathrm{d}S(t)}{\mathrm{d}t} =-\beta(t)\cdot\frac{S(t)Z(t)}{N} \,.
\end{align}
$$

<p>Similarly, the evolution of the sick population is given by:</p>
$$
\begin{align}
\tag{12}
\frac{\mathrm{d}Z(t)}{\mathrm{d}t} =+\beta(t)\cdot\frac{S(t)Z(t)}{N} \,.
\end{align}
$$

<p>This last equation can also be derived at once from the relation \( N=S(t)+Z(t) \).</p>
<h1 id="guidelines-for-project-submission" class="anchor">Guidelines for project submission </h1>

<p>You should bear the following points in mind when working on the project:</p>
<ul>
<li> Start your notebook by providing a short introduction in which you outline the nature of the problem(s) to be investigated.</li>
<li> End your notebook with a brief summary of what you feel you learned from the project (if anything). Also, if you have any general comments or suggestions for what could be improved in future assignments, this is the place to do it.</li>
<li> All code that you make use of should be present in the notebook, and it should ideally execute without any errors (especially run-time errors). If you are not able to fix everything before the deadline, you should give your best understanding of what is not working, and how you might go about fixing it.</li>
<li> Avoid duplicating code! If you find yourself copying and pasting a lot of code, it is a strong indication that you should define reuseable functions and/or classes.</li>
<li> If you use an algorithm that is not fully described in the assignment text, you should try to explain it in your own words. This also applies if the method is described elsewhere in the course material.</li>
<li> In some cases it may suffice to explain your work via comments in the code itself, but other times you might want to include a more elaborate explanation in terms of, e.g., mathematics and/or pseudocode.</li>
<li> In general, it is a good habit to comment your code (though it can be overdone).</li>
<li> When working with approximate solutions to equations, it is very useful to check your results against known exact (analytical) solutions, should they be available.</li>
<li> It is also a good test of a model implementation to study what happens at known 'edge cases'.</li>
<li> Any figures you include should be easily understandable. You should label axes appropriately, and depending on the problem, include other legends etc. Also, you should discuss your figures in the main text.</li>
<li> It is always good if you can reflect a little bit around <em>why</em> you see what you see.</li>
</ul>
<h1 id="bibliography" class="anchor">Bibliography </h1>

<!-- begin bibliography -->
<ol>
 <li> <div id="triambak2021random"></div> <b>S. Triambak and D. Mahapatra</b>.  A Random Walk Monte Carlo Simulation Study of COVID-19-Like Infection Spread, <em>Physica A: Statistical Mechanics and its Applications</em>, 574, pp. 126014, 2021.</li>
 <li> <div id="codling2008random"></div> <b>E. A. Codling, M. J. Plank and S. Benhamou</b>.  Random Walk Models in Biology, <em>Journal of the Royal Society Interface</em>, 5(25), pp. 813-834, 2008.</li>
 <li> <div id="bailey1967simulation"></div> <b>N. T. Bailey</b>.  The Simulation of Stochastic Epidemics in Two Dimensions, <em>Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability</em>, 1967.</li>
 <li> <div id="kelker1973random"></div> <b>D. Kelker</b>.  A Random Walk Epidemic Simulation, <em>Journal of the American Statistical Association</em>, 68(344), pp. 821-823, 1973.</li>
 <li> <div id="kermack1927contribution"></div> <b>W. O. Kermack and A. G. McKendrick</b>.  A Contribution to the Mathematical Theory of EpidemicsI, <em>Proceedings of the Royal Society of London. Series A, Containing Papers of a Mathematical and Physical Character</em>, 115(772), pp. 700-721, 1927.</li>
 <li> <div id="perez2009agent"></div> <b>L. Perez and S. Dragicevic</b>.  An Agent-Based Approach for Modeling Dynamics of Contagious Disease Spread, <em>International Journal of Health Geographics</em>, 8(1), pp. 1-17, 2009.</li>
 <li> <div id="badham2018developing"></div> <b>J. Badham, E. Chattoe-Brown, N. Gilbert, Z. Chalabi, F. Kee and R. F. Hunter</b>.  Developing Agent-Based Models of Complex Health Behaviour, <em>Health &amp; Place</em>, 54, pp. 170-177, 2018.</li>
 <li> <div id="kerr2021covasim"></div> <b>C. C. Kerr, R. M. Stuart, D. Mistry, R. G. Abeysuriya, K. Rosenfeld, G. R. Hart, R. C. N\'u\~nez, J. A. Cohen, P. Selvaraj, B. Hagedorn et al.</b>.  Covasim: an Agent-Based Model of COVID-19 Dynamics and Interventions, <em>PLOS Computational Biology</em>, 17(7), pp. e1009149, 2021.</li>
 <li> <div id="WikiDiamondPrincess"></div> <b>Wikipedia</b>.  COVID-19 Pandemic on Diamond Princess, 2021, (Accessed on 19/11/2021), <a href="https://en.wikipedia.org/wiki/COVID-19_pandemic_on_Diamond_Princess" target="_self"><tt>https://en.wikipedia.org/wiki/COVID-19_pandemic_on_Diamond_Princess</tt></a>.</li>
<li> <div id="davis2010serpent"></div> <b>W. Davis</b>.  The Serpent and the Rainbow, 2010.</li>
<li> <div id="snl"></div> Store Norske Leksikon.  Accessed: 2023-10-12, <a href="https://snl.no" target="_self"><tt>https://snl.no</tt></a>.</li>
</ol>
<!-- end bibliography -->
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
</ul>
<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
</body>
</html>

